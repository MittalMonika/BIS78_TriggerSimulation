/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// JetFinderMT.cxx

#include "JetRec/JetFinderMT.h"
#include <iomanip>
#include <sstream>
#include "fastjet/PseudoJet.hh"
#include "fastjet/ClusterSequence.hh"
#include "fastjet/ClusterSequenceArea.hh"
#include "fastjet/config.h"
#include "fastjet/AreaDefinition.hh"
#ifndef NO_JET_VARIABLER
#include "fastjet/contrib/VariableRPlugin.hh"
#endif
#include "xAODEventInfo/EventInfo.h"
#include "JetEDM/FastJetUtils.h"
#include "JetEDM/PseudoJetVector.h"
#include "JetEDM/ClusterSequence.h"

#include "JetEDM/FastJetLink.h"       // templated Jet_v1::setPseudoJet
#include "xAODJet/Jet_PseudoJet.icc"  // templated Jet_v1::setPseudoJet

// #include "JetRec/JetFromPseudojet.h"
#include <algorithm>

#ifdef USE_BOOST_AUTO
#include <boost/typeof/typeof.hpp>
#endif
#ifdef USE_BOOST_FOREACH
#include <boost/foreach.hpp>
#endif

using std::string;
using std::setw;
#ifndef NO_JET_VARIABLER
using fastjet::contrib::VariableRPlugin;
#endif
using xAOD::JetContainer;
// using jet::IConstituentUserInfo;
// using jet::JetConstituentFiller;

// typedef IJetFinderMT::NameList NameList;

//**********************************************************************

JetFinderMT::JetFinderMT(string name)
: AsgTool(name),
  // m_bld("JetFromPseudojet"),
  m_fjalg(fastjet::undefined_jet_algorithm),
  m_isVariableR(false) {
  declareProperty("JetAlgorithm", m_jetalg="AntiKt");
  declareProperty("JetRadius", m_jetrad =0.4);
  declareProperty("VariableRMinRadius", m_minrad =-1.0);
  declareProperty("VariableRMassScale", m_massscale =-1.0);
  declareProperty("PtMin", m_ptmin =0.0);
  declareProperty("GhostArea", m_ghostarea =0.0);
  declareProperty("RandomOption", m_ranopt =0);
  // declareProperty("JetBuilder", m_bld); // unused, TO REMOVE
}

//**********************************************************************

StatusCode JetFinderMT::initialize() {
  ATH_MSG_DEBUG("Initializing...");
  xAOD::JetAlgorithmType::ID ialg = xAOD::JetAlgorithmType::algId(m_jetalg);
  m_fjalg = xAOD::JetAlgorithmType::fastJetDef(ialg);
  if ( m_fjalg == fastjet::undefined_jet_algorithm ) {
    ATH_MSG_ERROR("Invalid jet algorithm name: " << m_jetalg);
    ATH_MSG_ERROR("Allowed values are Kt, CamKt, AntiKt, etc.");
    return StatusCode::FAILURE;
  }
  if ( m_jetrad <=0 ) {
    ATH_MSG_ERROR("Invalid jet size parameter: " << m_jetrad);
    return StatusCode::FAILURE;
  }
  /*
  if ( m_bld.empty() ) {
    ATH_MSG_ERROR("Unable to retrieve jet builder.");
  }
  ATH_CHECK(m_bld.retrieve());
  */

  fastjet::JetDefinition jetdef(m_fjalg, m_jetrad);
  PseudoJetVector empty;
  fastjet::ClusterSequence cs(empty, jetdef);
  cs.inclusive_jets(m_ptmin);
  m_isVariableR = m_minrad>=0.0 && m_massscale>=0.0;
#ifdef NO_JET_VARIABLER
  if ( isVariableR() ) {
    ATH_MSG_ERROR("Variable-R jet findng is not supported in theis build.");
  }
#endif

  // Input DataHandles
  m_eventinfokey = "EventInfo";
  ATH_CHECK( m_eventinfokey.initialize() );

  std::string sdrop = "ToolSvc.";
  std::string myname = name();
  std::string::size_type ipos = myname.find(sdrop);
  if ( ipos != std::string::npos ) myname.replace(ipos, sdrop.size(), "");
  std::string cname = "ClusterSequence_JetFinderMT_" + myname;

  cnameRKey = cname;
  cnameWKey = cname;
  ATH_CHECK( cnameRKey.initialize() );
  ATH_CHECK( cnameWKey.initialize() );

  return StatusCode::SUCCESS;
}

//**********************************************************************

int JetFinderMT::find(const PseudoJetContainer& pjContainer, 
                    xAOD::JetContainer & finalJets, 
                    xAOD::JetInput::Type inputtype ) const {

  constexpr bool doSave = true;
  return _find(pjContainer, finalJets, inputtype, doSave);
}

//**********************************************************************

int JetFinderMT::findNoSave(const PseudoJetContainer& pjContainer, 
                    xAOD::JetContainer & finalJets, 
                    xAOD::JetInput::Type inputtype ) const {

  constexpr bool doSave = false;
  return _find(pjContainer, finalJets, inputtype, doSave);
}

int JetFinderMT::_find(const PseudoJetContainer& pjContainer, 
                     xAOD::JetContainer & finalJets, 
                     xAOD::JetInput::Type inputtype,
                     bool doSave) const {

  if ( m_fjalg == fastjet::undefined_jet_algorithm ) {
    ATH_MSG_ERROR("Jet finder is not properly initiialized.");
    return 1;
  }

  std::vector<PseudoJet> vpj = pjContainer.asVectorPseudoJet();

  fastjet::JetDefinition jetdef(m_fjalg, m_jetrad);
#ifndef NO_JET_VARIABLER
  const VariableRPlugin* pvrp = 0;
  if ( isVariableR() ) {
    VariableRPlugin::ClusterType vct = VariableRPlugin::AKTLIKE;
    switch(m_fjalg) {
    case fastjet::kt_algorithm:        vct = VariableRPlugin::KTLIKE;  break;
    case fastjet::antikt_algorithm:    vct = VariableRPlugin::AKTLIKE; break;
    case fastjet::cambridge_algorithm: vct = VariableRPlugin::CALIKE;  break;
    default:
      ATH_MSG_ERROR("Invalid algorithm type for variable-R finding.");
    }
    pvrp = new VariableRPlugin(m_massscale, m_minrad, m_jetrad, vct, false);
    jetdef = fastjet::JetDefinition(pvrp);
  }
#else
  if ( isVariableR() ) {
    ATH_MSG_ERROR("Variable-R jet findng is not supported in theis build.");
  }
#endif
  fastjet::ClusterSequence* pcs = 0;
  if ( m_ghostarea <= 0 ) {
    ATH_MSG_DEBUG("Creating input cluster sequence");
    pcs = new fastjet::ClusterSequence(vpj, jetdef);
  } else {
    fastjet::GhostedAreaSpec gspec(5.0, 1, m_ghostarea);
    if ( m_ranopt == 1 ) {
      // Use run/event number as random number seeds.
      std::vector<int> inseeds;
      auto handle_in = SG::makeHandle(m_eventinfokey);
      const xAOD::EventInfo* pevinfo;
      if ( handle_in.isValid() ) {
        pevinfo = handle_in.cptr();
      } else {
        pevinfo = 0;
      }

      if ( pevinfo != 0 ) {
#ifdef USE_BOOST_AUTO
        BOOST_AUTO(ievt, pevinfo->eventNumber());
        BOOST_AUTO(irun, pevinfo->runNumber());
#else
        auto ievt = pevinfo->eventNumber();
        auto irun = pevinfo->runNumber();
#endif
        if ( pevinfo->eventType(xAOD::EventInfo::IS_SIMULATION)) {
          // For MC, use the channel and MC event number
          ievt = pevinfo->mcEventNumber();
          irun = pevinfo->mcChannelNumber();
        }
        inseeds.push_back(ievt);
        inseeds.push_back(irun);
      } else {
        ATH_MSG_ERROR("Unable to retrieve event info");
      }
      if ( inseeds.size() ) gspec.set_random_status(inseeds);
    } // if (m_ranopt==1)
    ATH_MSG_DEBUG("Active area specs:");
    ATH_MSG_DEBUG("  Requested ghost area: " << m_ghostarea);
    ATH_MSG_DEBUG("     Actual ghost area: " << gspec.actual_ghost_area());
    ATH_MSG_DEBUG("               Max eta: " << gspec.ghost_etamax());
    ATH_MSG_DEBUG("              # ghosts: " << gspec.n_ghosts());
    ATH_MSG_DEBUG("       # rapidity bins: " << gspec.nrap());
    ATH_MSG_DEBUG("            # phi bins: " << gspec.nphi());
    std::vector<int> seeds;
    gspec.get_random_status(seeds);
    if ( seeds.size() == 2 ) {
      ATH_MSG_DEBUG("          Random seeds: " << seeds[0] << ", " << seeds[1]);
    } else {
      ATH_MSG_WARNING("Random generator size is not 2: " << seeds.size());
      ATH_MSG_DEBUG("          Random seeds: ");
#ifdef USE_BOOST_FOREACH
      BOOST_FOREACH(unsigned int seed, seeds) ATH_MSG_DEBUG("                 " << seed);
#else
      for ( auto seed : seeds ) ATH_MSG_DEBUG("                 " << seed);
#endif
    }
    fastjet::AreaDefinition adef(fastjet::active_area_explicit_ghosts, gspec);
    //fastjet::AreaDefinition adef(fastjet::active_area, gspec);
    ATH_MSG_DEBUG("Creating input area cluster sequence");
    pcs = new fastjet::ClusterSequenceArea(vpj, jetdef, adef);
  }

  ATH_MSG_DEBUG("Calling fastjet");
  ATH_MSG_DEBUG("vpj.size() = " << vpj.size());

  PseudoJetVector outs = sorted_by_pt(pcs->inclusive_jets(m_ptmin));
  ATH_MSG_DEBUG("Found jet count: " << outs.size());

  // FIXME JE
  //  NameList ghostlabs;
  // ghostlabs.push_back("");

  for ( auto & ipj: outs ) {
    
    // FIXME JE 31/01/2017
    
    //  xAOD::Jet* pjet = m_bld->add(*ijet, finalJets, inputtype, ghostlabs);
    
    //////////////////////////// BEGIN CODE SCOOPED FROM JetFromPseudojet
    /////////////////////////// Sort of....
    xAOD::Jet *pjet = new xAOD::Jet();
    finalJets.push_back(pjet);
    ATH_MSG_DEBUG("Sentinel 40");

    // TEMP DEBUG - REMOVE!
    ATH_MSG_DEBUG(pjContainer.toString(1));
    
    if(!pjContainer.extractConstituents(*pjet, ipj )){
      ATH_MSG_ERROR("Error assigning jet constituents");
      return 1;
    }
    ATH_MSG_DEBUG("Sentinel 50");
    

    xAOD::JetAlgorithmType::ID ialg = xAOD::JetAlgorithmType::algId(m_fjalg);
    pjet->setAlgorithmType(ialg);
    pjet->setSizeParameter(m_jetrad);
    if ( isVariableR() ) {
      pjet->setAttribute("VariableRMinRadius", m_minrad);
      pjet->setAttribute("VariableRMassScale", m_massscale);
    }
    pjet->setAttribute("JetGhostArea", m_ghostarea);
    ATH_MSG_DEBUG("Sentinel 100");

    // FIXME JE 03/02/2017
    pjet->setInputType(inputtype);
    
    // FIXME JE 06/02/2017
    ATH_MSG_VERBOSE("Creating jet from PseudoJet @ " << &ipj);
    double  px = ipj.px();
    double  py = ipj.py();
    double  pz = ipj.pz();
    double   e = ipj.e();
    double   m = ipj.m();
    double  pt = ipj.pt();
    double eta = ipj.eta();
    double phi = ipj.phi_std();
    double p2 = px*px + py*py + pz*pz;
    double p = sqrt(p2);
    double dpovere = p/e - 1.0;
    ATH_MSG_DEBUG("Sentinel 200");
    if ( m < 0.0 ) {
      if ( dpovere > 1.e-6 ) {  // Worse than float rounding error
        ATH_MSG_WARNING("...........................");
        ATH_MSG_WARNING("Found jet with negative mass: E, p, m, p/E-1 = "
                        << e << ", " << p << ", " << m << ", " << p/e-1.0);
        ATH_MSG_WARNING(setw(12) << "px" << setw(12) << "py" << setw(12) << "pz"
                        << setw(12) << "E" << setw(12) << "p");
        ATH_MSG_WARNING(setw(12) << "---" << setw(12) << "---" << setw(12) << "---"
                        << setw(12) << "---" << setw(12) << "---");
        const PseudoJetVector cons = ipj.constituents();
        for ( PseudoJetVector::const_iterator icon=cons.begin(); icon!=cons.end(); ++icon ) {
          double cpx = icon->px();
          double cpy = icon->py();
          double cpz = icon->pz();
          double  ce = icon->e();
          double cp2 = cpx*cpx + cpy*cpy + cpz*cpz;
          double cp = sqrt(cp2);
          ATH_MSG_WARNING(setw(12) << int(cpx) << setw(12) << int(cpy) << setw(12) << int(cpz)
                          << setw(12) << int(ce) << setw(12) << int(cp));
        }
        ATH_MSG_WARNING("...........................");
      } else {  // Rounding error
        m = 0.0;
      }
    }
    ATH_MSG_DEBUG("Sentinel 300");
    ATH_MSG_VERBOSE("  Jet has pT = " << pt << " MeV, m = " << m << " MeV, eta = " << eta );

    //xAOD::Jet* pjet = new xAOD::Jet();
    // jets.push_back(pjet);

    pjet->setJetP4( xAOD::JetFourMom_t(pt,eta,phi,m) );
    pjet->setJetP4(xAOD::JetConstitScaleMomentum, pjet->jetP4());
    ATH_MSG_DEBUG("Sentinel 350");

    if ( ipj.associated_cluster_sequence() == 0 ) {
      ATH_MSG_DEBUG("Pseudojet: no cluster sequence, " << 
                    "cannot be copied to Jet.");
      std::cout<< "JetFinderMT::_find Pseudojet does not have a cluster "
               <<" sequence and so cannot be copied to Jet.\n";
    } else {
      std::cout<< "JetFinderMT::_find Pseudojet has a cluster sequence, "
               << " will  be copied to Jet.\n";
    }

    // despite the above message,
    // previous code adds the pseudojet to the jet in all cases
    // at the moment (19/12/2017)  this causes fast jet error messages
    //PS 318/03/24pjet->setPseudoJet(&ipj);
    //constituentsDEBUG(*pjet, "JetFinderMT::_find");

    // Record the jet-finding momentum, i.e. the one used to find/groom the jet.
    pjet->setJetP4(xAOD::JetConstitScaleMomentum, pjet->jetP4());
 
    // FIXME
    bool m_doArea = true;
    bool m_doFourVecArea = true;

    ATH_MSG_DEBUG("Sentinel 400");

    if ( m_doArea || m_doFourVecArea ) {
      if ( ipj.has_area() ) {
        if ( m_doArea ) {
          pjet->setAttribute("ActiveArea", ipj.area());
          ATH_MSG_VERBOSE("Recording jet area: " << ipj.has_area());
        }
        if ( m_doFourVecArea ) {
          fastjet::PseudoJet pja = ipj.area_4vector();
          xAOD::JetFourMom_t fvarea(pja.pt(), pja.eta(), pja.phi(), pja.m());      
          pjet->setAttribute("ActiveArea4vec", fvarea);
          ATH_MSG_VERBOSE("Recording jet four-vector area.");
        }
      } else {
        ATH_MSG_WARNING("Save of active area attribute requested for jet without area.");
      }
    } else {
      if ( ipj.has_area() ) {
        ATH_MSG_VERBOSE("No area recorded for jet with area.");
      }
    }
    
    ATH_MSG_DEBUG("Sentinel 500");
    

    // Set the jet's constituent scale.
    // Calibrated for all but EMTopo.
    ATH_MSG_VERBOSE("Done add with input");
    if ( (inputtype == xAOD::JetInput::EMTopo ) || 
         (inputtype == xAOD::JetInput::EMPFlow ) ) {
      ATH_MSG_VERBOSE("Setting constituent state to uncalibrated state");
      pjet->setConstituentsSignalState(xAOD::UncalibratedJetConstituent);
    } else {
      ATH_MSG_VERBOSE("Setting constituent state to calibrated state");
      pjet->setConstituentsSignalState(xAOD::CalibratedJetConstituent);
    }

    if ( pjet->getConstituentsSignalState() == xAOD::UncalibratedJetConstituent ) {
      // If constituents are already uncalibrated, the momentum is the same.
      pjet->setJetP4(xAOD::JetEMScaleMomentum, pjet->jetP4());
      ATH_MSG_DEBUG("  EM scale momentum set to jet scale");
    } else if ( (inputtype == xAOD::JetInput::EMTopoOrigin) ||
                (inputtype == xAOD::JetInput::LCTopoOrigin) ||
                (inputtype == xAOD::JetInput::LCTopo) ||
                (inputtype == xAOD::JetInput::LCPFlow)|| 
                (inputtype == xAOD::JetInput::EMCPFlow) ) {
      // fetch and sum the uncalibrated constituent momenta
      xAOD::JetConstituentVector vec = pjet->getConstituents();
      if(! vec.isValid() ) {
        ATH_MSG_ERROR("Jet constituent vector is invalid. Can't set EM scale momentum");
        continue;
      }

      xAOD::JetFourMom_t emscaleSum;
      xAOD::JetConstitScale uncal = xAOD::UncalibratedJetConstituent;
      // just sum 4-vectors:
      ATH_MSG_VERBOSE("  Summing four vectors.");
      for (auto it=vec.begin(uncal); it != vec.end(uncal); ++it) {
        emscaleSum +=**it;
      }
  
      ATH_MSG_VERBOSE("  Setting EM scale momentum");
      pjet->setJetP4(xAOD::JetEMScaleMomentum, emscaleSum);        
      ATH_MSG_DEBUG("  EM scale momentum set with uncalibrated constituents.");
      
    } else {
      ATH_MSG_DEBUG("  EM scale momentum not set.");
    }

  }
  ATH_MSG_DEBUG("Sentinel 600");

  ATH_MSG_DEBUG("Reconstructed jet count: " << finalJets.size() 
                <<  "  clusterseq="<<pcs);
  
  // (outs.size() && doSave) ? save(pcs) : delete pcs;
  if(doSave){save(pcs);}  // do not delete as needed by the trigger
  // vpj.clear();
  
  return 0;

}

//**********************************************************************

void JetFinderMT::save(fastjet::ClusterSequence* pcs) const {

  auto handle_out = SG::makeHandle(cnameWKey);
  if ( ! handle_out.record( std::unique_ptr<fastjet::ClusterSequence>(pcs)) ) {
    ATH_MSG_WARNING("Unable to record " << cnameWKey.key());
  } else {
    ATH_MSG_DEBUG("Recorded " << cnameWKey.key() << "   " << pcs );
  }
  auto handle_in = SG::makeHandle(cnameRKey);
  bool present = false;
  if ( handle_in.isValid()) {
    present = true;
  }
  ATH_MSG_DEBUG("Check presence: " << present);
  ATH_MSG_DEBUG("Will delete self: " << pcs->will_delete_self_when_unused());
  const fastjet::SharedPtr<fastjet::PseudoJetStructureBase>& shrptr = pcs->structure_shared_ptr();
  ATH_MSG_DEBUG("  Pointer: " << shrptr.get());
  ATH_MSG_DEBUG("  Use count: " << shrptr.use_count());
}

//**********************************************************************

bool JetFinderMT::isVariableR() const {
  return m_isVariableR;
}

//**********************************************************************

void JetFinderMT::print() const {
  ATH_MSG_INFO("      Jet algorithm: " << m_jetalg);
  if ( isVariableR() ) {
    ATH_MSG_INFO("         Variable-R: true");
    ATH_MSG_INFO("         min radius: " << m_minrad);
    ATH_MSG_INFO("         max radius: " << m_jetrad);
    ATH_MSG_INFO("         mass scale: " << m_massscale);
  } else {
    ATH_MSG_INFO(" Jet size parameter: " << m_jetrad);
  }
  ATH_MSG_INFO("   Jet min pT [MeV]: " << m_ptmin);
  ATH_MSG_INFO("         Ghost area: " << m_ghostarea);
  ATH_MSG_INFO("       Output level: " << MSG::name(msg().level()));
}

//**********************************************************************
