/* -*- C++ -*- */

/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

/** @file StoreGateSvc.icc
 */

#ifndef STOREGATE_STOREGATESVC_ICC
#define STOREGATE_STOREGATESVC_ICC
#include "AthenaKernel/ClassName.h"
#include <vector>

/// macro to help writing the function calls.
/// first looks if there is a hive slot defined, otherwise forwards to the "serial" implementation
#define _SGXCALL(FUN,ARGS,ONERR)                                        \
  SGImplSvc* impl = this->currentStore();                               \
  if (impl) {                                                           \
    return impl->FUN ARGS;                                              \
  }                                                                     \
  return ONERR;


/// macro to help writing the function calls
#define _SGVOIDCALL(FUN,ARGS)                                           \
  SGImplSvc* impl = this->currentStore();                               \
  if (impl) {                                                           \
    impl->FUN ARGS;                                                     \
  }


inline
StoreID::type 
StoreGateSvc::storeID() const
{
  return m_storeID;
}


inline
SGImplSvc*
StoreGateSvc::currentStore() const {
  if (m_storeID == StoreID::EVENT_STORE) {
    SG::HiveEventSlot* slot = s_pSlot;
    if (slot) return slot->pEvtStore;
  }
  return m_defaultStore;
}


inline
SG::DataProxy* 
StoreGateSvc::proxy(const CLID& id, const char* key) const {
  _SGXCALL( proxy, (id, key), 0 ); 
}

inline
SG::DataProxy* 
StoreGateSvc::proxy_exact (SG::sgkey_t sgkey) const { 
  _SGXCALL( proxy_exact, (sgkey), 0 ); 
}

template <typename H, typename TKEY>
StatusCode 
StoreGateSvc::regHandle( const DataHandle<H>& handle, const TKEY& key )
{
  CLID clid = ClassID_traits<H>::ID();
  IResetable *ir = const_cast<IResetable*> (static_cast<const IResetable*> (&handle));
  SG::DataProxy *dp = 0;

  bool ret = this->currentStore()->bindHandleToProxyAndRegister (clid, key, ir, dp);
  if (!ret) {
    return StatusCode::FAILURE;
  }

  return handle.setState(dp); // FIXME - should be retrieve?
}

/// non-const method - will return an error
template <typename H, typename TKEY>
StatusCode 
StoreGateSvc::regHandle( DataHandle<H>& handle, const TKEY& key)
{
  error() << "regHandle(): DataHandle must be const: "
          << ClassName<H>::name() << "[" + key + "]"
          << endmsg;

  return StatusCode::FAILURE;
}

/// register a callback function, with handle + key
template <typename T, typename H, typename TKEY>
StatusCode 
StoreGateSvc::regFcn(StatusCode (T::*updFcn)(IOVSVC_CALLBACK_ARGS), 
                     const T* obj, const DataHandle<H>& handle, 
                     const TKEY& key, bool trigger)
{
  CLID clid = ClassID_traits<H>::ID();
  IResetable *ir = const_cast<IResetable*> (static_cast<const IResetable*> (&handle));
  SG::DataProxy *dp = 0;

  const CallBackID c(updFcn,obj);
  IOVSvcCallBackFcn fcn(boost::bind(updFcn,const_cast<T*>(obj),_1,_2));

  bool ret = this->currentStore()->bindHandleToProxyAndRegister
                                    (clid, key, ir, dp, c, fcn, trigger);

  if (!ret) {
    return StatusCode::FAILURE;
  }

  return handle.setState(dp); // FIXME - should be retrieve?
}

/// register a callback function, with handle + key. Non const. Error
template <typename T, typename H, typename TKEY>
StatusCode 
StoreGateSvc::regFcn(StatusCode (T::* /*updFcn*/)(IOVSVC_CALLBACK_ARGS), 
                     const T* /*obj*/, DataHandle<H>& /*handle*/, 
                     const TKEY& key, bool /*trigger*/)
{
  error() << "regHandle(): DataHandle must be const: "
          << ClassName<H>::name() << "[" + key + "]"
          << endmsg;

  return StatusCode::FAILURE;
}


/// register a callback function(2) with an already registered function(1)
template <typename T1, typename T2>
StatusCode 
StoreGateSvc::regFcn(StatusCode (T1::*fcn1)(IOVSVC_CALLBACK_ARGS), 
                     const T1* obj1,
                     StatusCode (T2::*fcn2)(IOVSVC_CALLBACK_ARGS), 
                     const T2* obj2, bool trigger) {
  _SGXCALL( regFcn, (fcn1, obj1, fcn2, obj2, trigger), StatusCode::FAILURE );
}


/// register a callback function(2) with an already registered AlgTool
template <typename T2>
StatusCode 
StoreGateSvc::regFcn(const std::string& toolName,
                     StatusCode (T2::*fcn2)(IOVSVC_CALLBACK_ARGS), 
                     const T2* obj2, bool trigger) {
  _SGXCALL( regFcn, (toolName, fcn2, obj2, trigger), StatusCode::FAILURE );
}

#ifndef BOOST_NO_CXX11_TEMPLATE_ALIASES
#ifndef BOOST_NO_CXX11_VARIADIC_TEMPLATES
///////////////////////////////////////////////////////////////////
// create an object and record it with key
//////////////////////////////////////////////////////////////////
template <typename T, typename TKEY, typename... ARGS>
SG::WPtr<T> 
StoreGateSvc::create(const TKEY& key, ARGS... constructorArgs) {
  T* pT = new T(constructorArgs...);
  if(!(this->record(pT, key).isSuccess())) {
    error() << "create: problem recording created object @" 
            << pT << " using key " << key << endmsg;
    pT=0; //record will take care of deleting pT even if it fails
  }
  return pT;
}
#endif
#endif
///////////////////////////////////////////////////////////////////
// record an object with key
//////////////////////////////////////////////////////////////////
template <typename T, typename TKEY> 
StatusCode StoreGateSvc::record(std::auto_ptr<T> pAuto, const TKEY& key)
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRecord (ClassID_traits<T>::ID(), key);
  }
  const bool ALLOWMODS(true);
  _SGXCALL(record, (pAuto.release(), key, ALLOWMODS), StatusCode::FAILURE); //SG takes ownership
}

template <typename T, typename TKEY> 
StatusCode 
StoreGateSvc::overwrite(std::auto_ptr<T> p2BRegistered, const TKEY& key) 
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRecord (ClassID_traits<T>::ID(), key);
  }
  _SGXCALL(overwrite, (p2BRegistered, key), StatusCode::FAILURE);
}

//-------------------------------------------------------------------
template <typename T, typename TKEY> 
StatusCode StoreGateSvc::record(T* pObject, const TKEY& key)
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRecord (ClassID_traits<T>::ID(), key);
  }
  const bool ALLOWMODS(true);
  _SGXCALL(record, (pObject, key, ALLOWMODS), StatusCode::FAILURE);
}
//-------------------------------------------------------------------
template <typename T, typename TKEY>
StatusCode StoreGateSvc::record(const T* pObject, const TKEY& key)
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRecord (ClassID_traits<T>::ID(), key);
  }
  const bool NOMODS(false);
  _SGXCALL(record, (const_cast<T*>(pObject), key, NOMODS), StatusCode::FAILURE);
}

//-------------------------------------------------------------------
template <typename T, typename TKEY> 
StatusCode StoreGateSvc::record(T* pObject, const TKEY& key, 
                                bool allowMods, bool resetOnly, bool noHist)
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRecord (ClassID_traits<T>::ID(), key);
  }
  _SGXCALL(record, (pObject, key, allowMods, resetOnly, noHist ), StatusCode::FAILURE);
}
//////////////////////////////////////////////////////////////////
// Retrieve the default object (with no key) as a const pointer
//////////////////////////////////////////////////////////////////
template <typename T> 
StatusCode StoreGateSvc::retrieve(const T*& ptr) const
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRetrieve (ClassID_traits<T>::ID(), "");
  }
  _SGXCALL(retrieve, (ptr), StatusCode::FAILURE);
}

//////////////////////////////////////////////////////////////////
// Retrieve the default object (with no key) as a pointer (non-const)
//////////////////////////////////////////////////////////////////
template <typename T> 
StatusCode StoreGateSvc::retrieve(T*& ptr) const
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRetrieve (ClassID_traits<T>::ID(), "");
  }
  _SGXCALL(retrieve, (ptr), StatusCode::FAILURE);
}

//////////////////////////////////////////////////////////////////
// Retrieve the keyed object as a const pointer
//////////////////////////////////////////////////////////////////
template <typename T, typename TKEY>
StatusCode StoreGateSvc::retrieve(const T*& ptr, const TKEY& key) const
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRetrieve (ClassID_traits<T>::ID(), key);
  }
  _SGXCALL(retrieve, (ptr, key), StatusCode::FAILURE);
}

//////////////////////////////////////////////////////////////////
// Retrieve the keyed object as a non-const pointer
//////////////////////////////////////////////////////////////////
template <typename T, typename TKEY>
StatusCode StoreGateSvc::retrieve(T*& ptr, const TKEY& key) const
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRetrieve (ClassID_traits<T>::ID(), key);
  }
  _SGXCALL(retrieve, (ptr, key), StatusCode::FAILURE);
}

/// Retrieve all objects of type T: returns an SG::ConstIterator range
template <typename T> 
StatusCode 
StoreGateSvc::retrieve(SG::ConstIterator<T>& begin, 
                       SG::ConstIterator<T>& end) const {
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRetrieve (ClassID_traits<T>::ID(), "(iterator)");
  }
  _SGXCALL(retrieve, (begin, end), StatusCode::FAILURE);
}


/**
 * @brief Retrieve an object of type @c T from StoreGate.
 *        Return 0 if not found.
 **/

template <typename T>
T* StoreGateSvc::retrieve () const
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    typedef typename std::remove_cv<T>::type base_type;
    rememberBadRetrieve (ClassID_traits<base_type>::ID(), "");
  }
  _SGXCALL(retrieve<T>, (), 0);
}

/**
 * @brief Retrieve an object of type @c T from StoreGate.
 *        Return 0 if not found.
 * @param key The key to use for the lookup.
 **/
template <typename T, class TKEY>
T* StoreGateSvc::retrieve (const TKEY& key) const
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    typedef typename std::remove_cv<T>::type base_type;
    rememberBadRetrieve (ClassID_traits<base_type>::ID(), key);
  }
  _SGXCALL(retrieve<T>, (key), 0);
}

/**
 * @brief Retrieve an object of type @c T from StoreGate.
 *        Return 0 if not found.
 **/
template <typename T>
T* StoreGateSvc::tryRetrieve () const
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRetrieve (ClassID_traits<T>::ID(), "");
  }
  _SGXCALL(tryRetrieve<T>, (), 0);
}

template <typename T>
const T* StoreGateSvc::tryConstRetrieve() const
{
  _SGXCALL(tryConstRetrieve<T>, (), 0);
}

/**
 * @brief Retrieve an object of type @c T from StoreGate.
 *        Return 0 if not found. Don't print any WARNINGs
 * @param key The key to use for the lookup.
 **/
template <typename T, class TKEY>
T* StoreGateSvc::tryRetrieve (const TKEY& key) const
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRetrieve (ClassID_traits<T>::ID(), key);
  }
  _SGXCALL(tryRetrieve<T>, (key), 0);
}

template <typename T, class TKEY>
const T* StoreGateSvc::tryConstRetrieve (const TKEY& key) const
{
  _SGXCALL(tryConstRetrieve<T>, (key), 0);
}

template <typename T>
int StoreGateSvc::typeCount() const
{
  return typeCount(ClassID_traits<T>::ID());
}


template <typename T, typename TKEY> 
bool 
StoreGateSvc::contains(const TKEY& key) const 
{
  return this->contains(ClassID_traits<T>::ID(), key);
}

template <typename TKEY> 
bool 
StoreGateSvc::contains(const CLID& clid, const TKEY& key) const 
{
  _SGXCALL( contains, (clid,key), false );
}

template <typename T, typename TKEY> 
bool 
StoreGateSvc::transientContains(const TKEY& key) const 
{
  return transientContains(ClassID_traits<T>::ID(), key);
}



template <typename TKEY>
bool 
StoreGateSvc::transientContains(const CLID& id, const TKEY& key) const
{
  _SGXCALL(transientContains, (id, key), false);
}

//-------------------------end of contains methods--------------------
template <typename T>
void
StoreGateSvc::keys(std::vector<std::string>& vkeys, 
                   bool includeAlias, bool onlyValid) {
  return this->keys(ClassID_traits<T>::ID(), vkeys, includeAlias, onlyValid);
} 


template <typename T, typename TKEY>
StatusCode 
StoreGateSvc::bind(const DataHandle<T>& handle, const TKEY& key) {
  CLID clid = ClassID_traits<T>::ID();
  IResetable *ir = const_cast<IResetable*> (static_cast<const IResetable*> (&handle));
  SG::DataProxy *dp = 0;
  bool ret = this->currentStore()->bindHandleToProxy (clid, key, ir, dp);
  if (!ret) {
    return StatusCode::FAILURE;
  }

  return handle.setState(dp); // FIXME - should be retrieve?
}

#if __cplusplus > 201100
//-------------------------------------------------------------------
template <typename T, typename TKEY> 
StatusCode StoreGateSvc::record(std::unique_ptr<T> pUnique, const TKEY& key)
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRecord (ClassID_traits<T>::ID(), key);
  }
  _SGXCALL(record, (std::move(pUnique), key), StatusCode::FAILURE);
}
//-------------------------------------------------------------------
template <typename T, typename TKEY>
StatusCode StoreGateSvc::record(std::unique_ptr<const T> pUnique,
                                const TKEY& key)
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRecord (ClassID_traits<T>::ID(), key);
  }
  _SGXCALL(record, (std::move(pUnique), key), StatusCode::FAILURE);
}

//-------------------------------------------------------------------
template <typename T, typename TKEY> 
StatusCode StoreGateSvc::record(std::unique_ptr<T> pUnique, const TKEY& key, 
                                bool allowMods, bool resetOnly, bool noHist)
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRecord (ClassID_traits<T>::ID(), key);
  }
  _SGXCALL(record, (std::move(pUnique), key, allowMods, resetOnly, noHist), StatusCode::FAILURE);
}
#endif

template <typename T, typename TKEY> 
StatusCode StoreGateSvc::overwrite(T* p2BRegistered, const TKEY& key)
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRecord (ClassID_traits<T>::ID(), key);
  }
  const bool ALLOWMODS(true);
  return overwrite(p2BRegistered, key, ALLOWMODS); //SG takes ownership
}

template <typename T, typename TKEY> 
StatusCode 
StoreGateSvc::overwrite(T* pObject, const TKEY& key, 
                        bool allowMods, bool noHist) 
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRecord (ClassID_traits<T>::ID(), key);
  }
  _SGXCALL(overwrite, (pObject, key, allowMods, noHist), StatusCode::FAILURE);
}

#if __cplusplus > 201100
template <typename T, typename TKEY> 
StatusCode StoreGateSvc::overwrite(std::unique_ptr<T> pUnique, const TKEY& key)
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRecord (ClassID_traits<T>::ID(), key);
  }
  _SGXCALL(overwrite, (std::move(pUnique), key), StatusCode::FAILURE);
}

template <typename T, typename TKEY> 
StatusCode StoreGateSvc::overwrite(std::unique_ptr<T> pUnique, const TKEY& key, 
                                   bool allowMods, bool noHist)
{
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRecord (ClassID_traits<T>::ID(), key);
  }
  _SGXCALL(overwrite, (std::move(pUnique), key, allowMods, noHist), StatusCode::FAILURE);
}
#endif

template <typename T, typename AKEY>
StatusCode StoreGateSvc::setAlias(const T* pObject, const AKEY& aKey)
{
  _SGXCALL(setAlias, (pObject, aKey), StatusCode::FAILURE);
}
//-------------------------------------------------------------------
template <typename T, typename TKEY, typename AKEY>
StatusCode 
StoreGateSvc::setAlias(const T* dummy,
                       const TKEY& key, const AKEY& aKey)
{
  _SGXCALL(setAlias, (dummy, key, aKey), StatusCode::FAILURE);
}

//////////////////////////////////////////////////////////////////
// Make a soft link to the object with key: return non_const link
//////////////////////////////////////////////////////////////////
template <typename T, typename TLINK> 
StatusCode 
StoreGateSvc::symLink(const T* pObject, TLINK* dummy)
{
  _SGXCALL(symLink, (pObject, dummy), StatusCode::FAILURE);
}

//////////////////////////////////////////////////////////////////
// Make a soft link to the object with key: set const link
//////////////////////////////////////////////////////////////////
template <typename T, typename TLINK> 
StatusCode 
StoreGateSvc::symLink(const T* pObject, const TLINK* dummy)
{
  _SGXCALL(symLink, (pObject, dummy), StatusCode::FAILURE);
}

template <typename TKEY> 
StatusCode 
StoreGateSvc::symLink(const CLID& id, const TKEY& key, const CLID& linkid)
{
  _SGXCALL(symLink, (id, key, linkid), StatusCode::FAILURE);
}


/// Remove pObject,  will remove its proxy if not reset only.
template <typename T>
StatusCode 
StoreGateSvc::remove(const T* pObject) {
  _SGXCALL(remove, (pObject), StatusCode::FAILURE);
}

/// Remove pObject and its proxy no matter what.         
template <typename T>    
StatusCode 
StoreGateSvc::removeDataAndProxy(const T* pObject)  {
  _SGXCALL(removeDataAndProxy, (pObject), StatusCode::FAILURE);
}

template <typename T, class TKEY>
StatusCode 
StoreGateSvc::retrieveHighestVersion(SG::ObjectWithVersion<T>& dobjWithVersion, 
                                     const TKEY& requestedKey) const {
  _SGXCALL(retrieveHighestVersion, (dobjWithVersion, requestedKey), StatusCode::FAILURE);
}

template <typename T, class TKEY>
StatusCode
StoreGateSvc::retrieveAllVersions(std::list< SG::ObjectWithVersion<T> >& allVersions,
                                  const TKEY& requestedKey) const {
  _SGXCALL(retrieveAllVersions, (allVersions, requestedKey), StatusCode::FAILURE);
}


template <typename T>
std::auto_ptr<T> 
StoreGateSvc::readPrivateCopy (const std::string& key) {
  std::auto_ptr<T> nullT;
  _SGXCALL(readPrivateCopy<T>, (key), nullT);
}


template <typename T>
std::auto_ptr<T> 
StoreGateSvc::retrievePrivateCopy (const std::string& key) {
  std::auto_ptr<T> nullT;
  _SGXCALL(retrievePrivateCopy<T>, (key), nullT);
}

template <typename T>
std::unique_ptr<T> 
StoreGateSvc::readUniquePrivateCopy (const std::string& key) {
  SGImplSvc* impl = this->currentStore();
  if (impl) {
    return impl->readUniquePrivateCopy<T>(key);
  }
  return std::unique_ptr<T>();
}


template <typename T>
std::unique_ptr<T> 
StoreGateSvc::retrieveUniquePrivateCopy (const std::string& key) {
  SGImplSvc* impl = this->currentStore();
  if (impl) {
    return impl->retrieveUniquePrivateCopy<T>(key);
  }
  return std::unique_ptr<T>();
}

//////////////////////////////////////////////////////////////////
// Retrieve the @c CLID of a given "key" 
// WARNING: slow!
//////////////////////////////////////////////////////////////////
template<typename TKEY>
CLID 
StoreGateSvc::clid( const TKEY& key ) const
{
  _SGXCALL(clid, (key), CLID_NULL);
}

//////////////////////////////////////////////////////////////////
// Retrieve the @c CLID s of a given "key" 
// WARNING: slow!
//////////////////////////////////////////////////////////////////
template<typename TKEY>
std::vector<CLID> 
StoreGateSvc::clids( const TKEY& key ) const
{
  std::vector<CLID> nullV;
  _SGXCALL(clids, (key), nullV);
}

///////////////////////////////////////////////////////////////////////////

inline
void 
StoreGateSvc::setProxyProviderSvc(IProxyProviderSvc* pPPSvc) {
  _SGVOIDCALL(setProxyProviderSvc, (pPPSvc));
}


inline
IProxyProviderSvc*
StoreGateSvc::proxyProviderSvc() {
  _SGXCALL(proxyProviderSvc, (), nullptr);
}


/**
 * @brief Return the metadata source ID for the current event slot.
 *        Returns an empty string if no source has been set.
 *
 *        The default version always returns an empty string.
 */
inline
SG::SourceID
StoreGateSvc::sourceID() const {
  _SGXCALL(sourceID, (), "");
}


template <class TKEY>
void 
StoreGateSvc::remap (CLID clid,
                     const TKEY& source,
                     const TKEY& target,
                     off_t index_offset) {
  _SGVOIDCALL(remap, (clid, source, target, index_offset));
}


/// DEPRECATED: Retrieve the default object into a const DataHandle
template <typename T> 
StatusCode 
StoreGateSvc::retrieve(const DataHandle<T>& handle) const {
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRetrieve (ClassID_traits<T>::ID(), "");
  }

  SG::DataProxy* dp(this->proxy(ClassID_traits<T>::ID()));
  StatusCode sc = handle.setState(dp);

  if (sc.isFailure()) {
    warning() 
          << "retrieve(default): No valid proxy for default object \n" 
          << " of type "  << ClassID_traits<T>::typeName() << "(CLID " 
          << ClassID_traits<T>::ID() << ')' << endmsg;
  }
  else {
    // Skip associateAux for this deprecated method.
#ifndef NDEBUG
    SG_MSG_DEBUG("retrieve(default): Retrieved const handle to default object \n" 
                 << " of type "  << ClassID_traits<T>::typeName() 
                 << "(CLID " << ClassID_traits<T>::ID() << ')');
#endif
  }
  return sc;
}

/// DEPRECATED: Retrieve the default object into a DataHandle
template <typename T> 
StatusCode
StoreGateSvc::retrieve(DataHandle<T>& handle) const {
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRetrieve (ClassID_traits<T>::ID(), "");
  }

  SG::DataProxy* dp(this->proxy(ClassID_traits<T>::ID()));
  StatusCode sc = handle.setState(dp);

  if (sc.isFailure()) {
    warning() 
          << "retrieve(default): No valid proxy for default object " 
          << " of type "  << ClassID_traits<T>::typeName() << "(CLID "
          << ClassID_traits<T>::ID() << ")\n Try to use a const DataHandle " 
          << endmsg;
  }
  else {
    // Skip associateAux for this deprecated method.
#ifndef NDEBUG
    SG_MSG_DEBUG("Retrieved non-const handle to default object " 
                 << " of type "  << ClassID_traits<T>::typeName() 
                 << "(CLID " << ClassID_traits<T>::ID() << ')');
#endif
  }

  return sc;
}

/// DEPRECATED: Retrieve an object with "key", into a const DataHandle
template <typename T, typename TKEY> 
StatusCode 
StoreGateSvc::retrieve(const DataHandle<T>& handle, const TKEY& key) const {
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRetrieve (ClassID_traits<T>::ID(), key);
  }

#ifndef __clang__
  BOOST_CONCEPT_ASSERT( (KeyConcept<TKEY>) );
#endif

  SG::DataProxy* dp(this->proxy(ClassID_traits<T>::ID(), (std::string)key, false));
  StatusCode sc = handle.setState(dp);

  if (sc.isFailure()) {
    warning() 
          << "retrieve(const): No valid proxy for object " << key  << ' ' 
          << " of type "  << ClassID_traits<T>::typeName() << "(CLID "
          << ClassID_traits<T>::ID() << ')' << endmsg;
  }
  else {
    // Skip associateAux for this deprecated method.
#ifndef NDEBUG
    SG_MSG_DEBUG( "Retrieved const handle to object " << key  << ' '
                  << " of type "  << ClassID_traits<T>::typeName() 
                  << "(CLID " << ClassID_traits<T>::ID() << ')');
#endif
  }
  return sc;
}

/// DEPRECATED: Retrieve an object with "key", into a DataHandle
template <typename T, typename TKEY> 
StatusCode 
StoreGateSvc::retrieve(DataHandle<T>& handle, const TKEY& key) const {
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRetrieve (ClassID_traits<T>::ID(), key);
  }

#ifndef __clang__
  BOOST_CONCEPT_ASSERT( (KeyConcept<TKEY>) );
#endif

  SG::DataProxy* dp(this->proxy(ClassID_traits<T>::ID(), (std::string)key, false));
  StatusCode sc = handle.setState(dp);

  if (sc.isFailure()) {
    SG_MSG_WARNING("retrieve(non-const): No valid proxy for object "
                   << (std::string)key  << ' ' 
                   << " of type "  << ClassID_traits<T>::typeName() << "(CLID "
                   << ClassID_traits<T>::ID() 
                   << ") \n Try to use a const DataHandle" );
  }
  else {
    // Skip associateAux for this deprecated method.
#ifndef NDEBUG
    SG_MSG_DEBUG("Retrieved non-const handle to object " << (std::string)key  
                 << ' ' << " of type "  << ClassID_traits<T>::typeName() 
                 << "(CLID " << ClassID_traits<T>::ID() << ')');
#endif
  }
  return sc;
}

/// DEPRECATED Retrieve all objects of type T: use iterators version instead
/// BE AWARE: Iteration over DataHandle is not thread-safe!
template <typename T> 
StatusCode 
StoreGateSvc::retrieve(const DataHandle<T>& chbegin, 
                       const DataHandle<T>& chend) const {
  if (m_storeID == StoreID::EVENT_STORE && s_pSlot != nullptr) {
    rememberBadRetrieve (ClassID_traits<T>::ID(), "(iterator)");
  }

  SG::ConstProxyIterator first;
  SG::ConstProxyIterator end = first;

  if (!(this->proxyRange(ClassID_traits<T>::ID(),first,end)).isSuccess()) {
#ifndef NDEBUG
    SG_MSG_DEBUG("retrieve(range): no object found " 
                 << " of type "  << ClassID_traits<T>::typeName() 
                 << "(CLID " << ClassID_traits<T>::ID() << ')');
#endif
  }

  (chend.setState(end, end)).ignore();
  
  if (!(chbegin.setState(first, end)).isSuccess()) {
#ifndef NDEBUG
    SG_MSG_DEBUG("retrieve(range): Can't set DataHandle for object range " 
                 << " of type "  << ClassID_traits<T>::typeName() 
                 << "(CLID " << ClassID_traits<T>::ID() << ')');
#endif
    return StatusCode::FAILURE;
  }

  return StatusCode::SUCCESS;
}

/// DEPRECATED put a dobj pointer in a bucket as appropriate
/// see tools/StorableConversion.h for replacement
template <typename T>
DataObject* 
StoreGateSvc::asStorable(T* pDObj) {
  return SG::asStorable(pDObj);
}
/// DEPRECATED gets a dobj pointer from a bucket as appropriate
/// see tools/StorableConversion.h for replacement
template <typename T> 
bool 
StoreGateSvc::fromStorable(DataObject* pObject, T*& pData) {
  return SG::fromStorable(pObject, pData);
}


/// DEPRECATED, use version taking ref to vector
template <typename T>
std::vector<std::string> //FIXME inefficient. Should take ref to vector
StoreGateSvc::keys(bool allKeys) {
  std::vector<std::string> nullV;
  _SGXCALL( keys<T>, (allKeys), nullV );
}


/**
 * @brief Remember that retrieve() was called for a MT store.
 * @param clid CLID of the operation.
 * @param key Key of the operation.
 */
inline
void StoreGateSvc::rememberBadRetrieve (CLID clid, const std::string& key) const
{
  rememberBad (m_badRetrieves, clid, key);
}


/**
 * @brief Remember that retrieve() was called for a MT store.
 * @param clid CLID of the operation.
 * @param key Key of the operation.
 */
inline
void StoreGateSvc::rememberBadRecord (CLID clid, const std::string& key) const
{
  rememberBad (m_badRecords, clid, key);
}


#endif //STOREGATE_STOREGATESVC_ICC
