/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

// $Id$
/**
 * @file AthContainers/tools/AuxTypeVector.icc
 * @author scott snyder <snyder@bnl.gov>
 * @date Sep, 2013
 * @brief Implementation of @c IAuxTypeVector for specific types.
 */


namespace SG { 


/**
 * @brief Constructor.  Makes a new vector.
 * @param size Initial size of the new vector.
 * @param capacity Initial capacity of the new vector.
 */
template <class T, class V>
inline
AuxTypeVector1<T, V>::AuxTypeVector1 (size_t size, size_t capacity)
{
  m_vec.reserve (capacity * SCALE);
  m_vec.resize (size * SCALE);
}


/**
 * @brief Make a copy of this vector.
 */
template <class T, class V>
inline
IAuxTypeVector* AuxTypeVector1<T, V>::clone() const
{
  return new AuxTypeVector1<T, V> (*this);
}


/**
 * @brief Return a pointer to the start of the vector's data.
 */
template <class T, class V>
inline
void* AuxTypeVector1<T, V>::toPtr ()
{
  if (m_vec.empty())
    return 0;
  return &*m_vec.begin();
}


/**
 * @brief Return a pointer to the STL vector itself.
 */
template <class T, class V>
inline
void* AuxTypeVector1<T, V>::toVector ()
{
  return &m_vec;
}


/**
 * @brief Return the size of the vector.
 */
template <class T, class V>
inline
size_t AuxTypeVector1<T, V>::size () const
{
  return m_vec.size();
}


/**
 * @brief Change the size of the vector.
 * @param sz The new vector size.
 */
template <class T, class V>
inline
void AuxTypeVector1<T, V>::resize (size_t sz)
{
  m_vec.resize (sz * SCALE);
}


/**
 * @brief Change the capacity of the vector.
 * @param sz The new vector capacity.
 */
template <class T, class V>
inline
void AuxTypeVector1<T, V>::reserve (size_t sz)
{
  m_vec.reserve (sz * SCALE);
}


/**
 * @brief Shift the elements of the vector.
 * @param pos The starting index for the shift.
 * @param offs The (signed) amount of the shift.
 *
 * This operation shifts the elements in the vectors for all
 * aux data items, to implement an insertion or deletion.
 * @c offs may be either positive or negative.
 *
 * If @c offs is positive, then the container is growing.
 * The container size should be increased by @c offs,
 * the element at @c pos moved to @c pos + @c offs,
 * and similarly for following elements.
 * The elements between @c pos and @c pos + @c offs should
 * be default-initialized.
 *
 * If @c offs is negative, then the container is shrinking.
 * The element at @c pos should be moved to @c pos + @c offs,
 * and similarly for following elements.
 * The container should then be shrunk by @c -offs elements
 * (running destructors as appropriate).
 */
template <class T, class V>
void AuxTypeVector1<T, V>::shift (size_t pos, ptrdiff_t offs)
{
  if (offs < 0) {
    if (-offs > static_cast<ptrdiff_t>(pos)) offs = -pos;
    std::copy (m_vec.begin() + pos*SCALE,
               m_vec.end(),
               m_vec.begin() + (pos+offs)*SCALE);
    m_vec.resize (m_vec.size() + offs*SCALE);
  }
  else if (offs > 0) {
    size_t oldsz = m_vec.size();
    m_vec.resize (m_vec.size() + offs*SCALE);
    std::copy (m_vec.rbegin() + offs*SCALE,
               m_vec.rbegin() + (offs+oldsz-pos)*SCALE,
               m_vec.rbegin());
    std::fill (m_vec.begin() + pos*SCALE,
               m_vec.begin() + (pos+offs)*SCALE,
               T());
  }
}


/**
 * @brief Copy an element between vectors (static method).
 * @param dst Pointer to the start of the destination vector's data.
 * @param dst_index Index of destination element in the vector.
 * @param src Pointer to the start of the source vector's data.
 * @param src_index Index of source element in the vector.
 *
 * @c dst and @ src can be either the same or different.
 */
template <class T, class V>
inline
void AuxTypeVector1<T, V>::copy (void* dst,       size_t dst_index,
                                 const void* src, size_t src_index)
{
  (reinterpret_cast<typename V::value_type*>(dst))[dst_index] = 
    (reinterpret_cast<const typename V::value_type*>(src))[src_index];
}


/**
 * @brief Swap an element between vectors (static method).
 * @param a Pointer to the start of the first vector's data.
 * @param aindex Index of the element in the first vector.
 * @param b Pointer to the start of the second vector's data.
 * @param bindex Index of the element in the second vector.
 *
 * @c a and @ b can be either the same or different.
 */
template <class T, class V>
inline
void AuxTypeVector1<T, V>::swap (void* a, size_t aindex,
                                 void* b, size_t bindex)
{
  std::swap ((reinterpret_cast<typename V::value_type*>(a))[aindex],
             (reinterpret_cast<typename V::value_type*>(b))[bindex]);
}


/**
 * @brief Clear an element within a vector (static method).
 * @param dst Pointer to the start of the vector's data.
 * @param dst_index Index of the element in the vector.
 */
template <class T, class V>
inline
void AuxTypeVector1<T, V>::clear (void* dst, size_t dst_index)
{
  (reinterpret_cast<typename V::value_type*>(dst))[dst_index] = 
    typename V::value_type();
}    


//***************************************************************************


/**
 * @brief Constructor.  Makes a new vector.
 * @param size Initial size of the new vector.
 * @param capacity Initial capacity of the new vector.
 */
template <class T>
inline
AuxTypeVector<T>::AuxTypeVector (size_t size, size_t capacity)
  : AuxTypeVector1<T, std::vector<T> > (size, capacity)
{
}


//***************************************************************************


/**
 * @brief Constructor.  Makes a new vector.
 * @param size Initial size of the new vector.
 * @param capacity Initial capacity of the new vector.
 */
inline
AuxTypeVector<bool>::AuxTypeVector (size_t size, size_t capacity)
  : AuxTypeVector1<bool, std::vector<char> > (size, capacity)
{
}


} // namespace SG
