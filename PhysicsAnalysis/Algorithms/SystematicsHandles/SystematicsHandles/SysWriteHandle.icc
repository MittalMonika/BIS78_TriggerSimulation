/*
  Copyright (C) 2002-2018 CERN for the benefit of the ATLAS collaboration
*/

/// @author Nils Krumnack


//
// includes
//

#include <AsgTools/MessageCheck.h>
#include <SystematicsHandles/Helpers.h>

//
// method implementations
//

namespace CP
{
  template<typename T,typename Aux> inline MsgStream& SysWriteHandle<T,Aux> ::
  msg () const
  {
    assert (m_msg != nullptr);
    return *m_msg;
  }



  template<typename T,typename Aux> inline MsgStream& SysWriteHandle<T,Aux> ::
  msg (MSG::Level lvl) const
  {
    assert (m_msg != nullptr);
    *m_msg << lvl;
    return *m_msg;
  }



  template<typename T,typename Aux> template<typename T2> SysWriteHandle<T,Aux> ::
  SysWriteHandle (T2 *owner, const std::string& propertyName,
                 const std::string& propertyValue,
                 const std::string& propertyDescription)
    : m_outputName (propertyValue)
    , m_evtStoreGetter ([owner] () {return &*owner->evtStore();})
    , m_msg (&owner->msg())
  {
    owner->declareProperty (propertyName, m_outputName, propertyDescription);
  }



  template<typename T,typename Aux> ::StatusCode SysWriteHandle<T,Aux> ::
  record (std::unique_ptr<T> object, std::unique_ptr<Aux> aux,
          const CP::SystematicSet& sys) const
  {
    auto cache = m_outputNameCache.find (sys);
    if (cache == m_outputNameCache.end())
    {
      std::string newName = makeSystematicsName (m_outputName, sys);
      ANA_MSG_DEBUG ("SysWriteHandle: " << newName << " (" << sys.name() << ")");
      m_outputNameCache.insert (std::make_pair (sys, newName));
      cache = m_outputNameCache.find (sys);
      assert (cache != m_outputNameCache.end());
      if (!m_evtStore)
        m_evtStore = m_evtStoreGetter();
    }
    assert (m_evtStore);
    if (m_evtStore->record (aux.release(), cache->second + "Aux.").isFailure())
      return StatusCode::FAILURE;
    if (m_evtStore->record (object.release(), cache->second).isFailure())
      return StatusCode::FAILURE;
    return StatusCode::SUCCESS;
  }



  template<typename T,typename Aux> std::string SysWriteHandle<T,Aux> ::
  getInputAffecting () const
  {
    return "";
  }



  template<typename T> inline MsgStream& SysWriteHandle<T,void> ::
  msg () const
  {
    assert (m_msg != nullptr);
    return *m_msg;
  }



  template<typename T> inline MsgStream& SysWriteHandle<T,void> ::
  msg (MSG::Level lvl) const
  {
    assert (m_msg != nullptr);
    *m_msg << lvl;
    return *m_msg;
  }



  template<typename T> template<typename T2> SysWriteHandle<T,void> ::
  SysWriteHandle (T2 *owner, const std::string& propertyName,
                 const std::string& propertyValue,
                 const std::string& propertyDescription)
    : m_outputName (propertyValue)
    , m_evtStoreGetter ([owner] () {return &*owner->evtStore();})
    , m_msg (&owner->msg())
  {
    owner->declareProperty (propertyName, m_outputName, propertyDescription);
  }



  template<typename T> ::StatusCode SysWriteHandle<T,void> ::
  record (std::unique_ptr<T> object, const CP::SystematicSet& sys) const
  {
    auto cache = m_outputNameCache.find (sys);
    if (cache == m_outputNameCache.end())
    {
      std::string newName = makeSystematicsName (m_outputName, sys);
      ANA_MSG_DEBUG ("SysWriteHandle: " << newName << " (" << sys.name() << ")");
      m_outputNameCache.insert (std::make_pair (sys, newName));
      cache = m_outputNameCache.find (sys);
      assert (cache != m_outputNameCache.end());
      if (!m_evtStore)
        m_evtStore = m_evtStoreGetter();
    }
    assert (m_evtStore);
    return m_evtStore->record (object.release(), cache->second);
  }



  template<typename T> std::string SysWriteHandle<T,void> ::
  getInputAffecting () const
  {
    return "";
  }
}
