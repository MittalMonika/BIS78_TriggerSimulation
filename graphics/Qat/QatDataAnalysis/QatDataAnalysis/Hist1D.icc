//---------------------------------------------------------------------------//
//                                                                           //
// This file is part of the Pittsburgh Visualization System (PVS)            //
//                                                                           //
// Copyright (C) 2004 Joe Boudreau, University of Pittsburgh                 //
//                                                                           //
//  This program is free software; you can redistribute it and/or modify     //
//  it under the terms of the GNU General Public License as published by     //
//  the Free Software Foundation; either version 2 of the License, or        //
//  (at your option) any later version.                                      //
//                                                                           //
//  This program is distributed in the hope that it will be useful,          //
//  but WITHOUT ANY WARRANTY; without even the implied warranty of           //
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
//  GNU General Public License for more details.                             //
//                                                                           //
//  You should have received a copy of the GNU General Public License        //
//  along with this program; if not, write to the Free Software              //
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307     //
// --------------------------------------------------------------------------//
#include <algorithm>

class Hist1D::Clockwork {

public:

  std::string         name;                 
  size_t              nBins;                 
  double              min;                   
  double              max;                   
  double              binWidth;              
  size_t              overflow;              
  size_t              underflow;             
  size_t              entries;               
  double              xW;                    
  double              xxW;                   
  double              sumWeight;             
  mutable double      minContents;           
  mutable double      maxContents;
  std::vector<double> contents;
  std::vector<double> errors;

};  

inline std::string & Hist1D::name()  { return m_c->name;}

inline const std::string & Hist1D::name() const { return m_c->name;}

inline size_t Hist1D::nBins() const { return m_c->nBins;}

inline double Hist1D::min() const {return m_c->min;}

inline double Hist1D::max() const {return m_c->max;}

inline double Hist1D::binWidth () const {return m_c->binWidth;}

inline double Hist1D::binUpperEdge(unsigned int i) const {return m_c->min + (i+1)*m_c->binWidth;}

inline double Hist1D::binLowerEdge(unsigned int i) const {return m_c->min + i*m_c->binWidth;}

inline double Hist1D::binCenter(unsigned int i) const { return m_c->min + (i+0.5)*m_c->binWidth;}

inline double Hist1D::bin(unsigned int i) const {return m_c->contents[i];}

inline double Hist1D::binError(unsigned int i) const {return sqrt(m_c->errors[i]);}

inline size_t Hist1D::overflow() const {return m_c->overflow;}

inline size_t Hist1D::underflow() const {return m_c->underflow;}

inline double Hist1D::variance() const { 
  if (m_c->sumWeight==0) {
    return 0;
  }
  else {
    return  m_c->xxW/m_c->sumWeight-(m_c->xW*m_c->xW/m_c->sumWeight/m_c->sumWeight);
  }
}

inline double Hist1D::mean() const { 
  if (m_c->sumWeight==0) {
    return 0;
  }
  else {
    return  m_c->xW/m_c->sumWeight;
  }

}

inline double Hist1D::sum() const { return m_c->sumWeight;}

inline double Hist1D::minContents () const { 
  if (m_c->minContents==0) {
    if (m_c->entries!=0) {
      std::vector<double>::const_iterator min = std::min_element(m_c->contents.begin(),m_c->contents.end());
      if (min!=m_c->contents.end()) {
	m_c->minContents=*min;
      }
    }
  }
  return m_c->minContents;
}

inline double Hist1D::maxContents() const {
  if (m_c->maxContents==0) {
    if (m_c->entries!=0) {
      std::vector<double>::const_iterator max = std::max_element(m_c->contents.begin(),m_c->contents.end());
      if (max!=m_c->contents.end()) {
	m_c->maxContents=*max;
      }
    }
  }
  return m_c->maxContents;
}

inline size_t Hist1D::entries() const {return m_c->entries;}
