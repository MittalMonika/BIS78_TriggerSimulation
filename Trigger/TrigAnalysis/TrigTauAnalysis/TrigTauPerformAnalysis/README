// README File
// Package : TrigTauPerformAnalysis
// Author  : Eric Torrence (University of Oregon)
// Created : February 2007

Overview:

   This README is intended to describe the structure behind the
analysis objects found in the TrigTauPerformanceAnalysis package.

MC Truth:

   MC truth comes from the TrigTauPerformNtuple/TrigTauMCTauList
class.  This class takes a pointer to the TrigTauMCEvent (stored
in the ntuple), goes through the particle listing and finds valid
tau records, with duplicates removed and stores these into the
_mcTauPure vector.  A second step applies user-controlled fiducial
cuts, incuding potentially on the tau decay mode, and creates
the _mcTauGood vector.  This vector should be used as the 
denominator for any efficiency calculation, as shown in the
example macros. 

   These vectors contian TrigTauMCTau objects, which inherit from
the ntuple object TrigTauTrueParticle, but also provides specific
functions to provide the tau decay mode as well as the visible
momentum 4-vector.

Trigger Chains:

   One feature of the Atlas trigger system is the vertical
relationship between a single L1 ROI and a single L2 and EF
object.  Unfortunately, at the moment, there is no way to
precisely determing which L2 objects belongs to which L1 ROI.
To get around this, trigger chains are built by starting with
each L1 ROI in the event, and assigning L2 and EF objects
to one and only one chain by selecting the closest ROI in
R = sqrt(dEta^2 + dPhi^2).  

   The TrigTauTrigChainList class contains this list of
chains returned by the trigChainEntry function, but also
provides an interface to lists of chains passing specific
trigger conditions.  The selections are defined by the
TrigTauSelectionManager class (described below).  The main 
reason for the trigger chains is to require a L2 object to
also pass L1 for the associated ROI (which otherwise would
not be possible).

   Accessors are available to find all chains passing a
certain set of trigger criteria (L1/L2/EF), or to find the
chain containing a trigger object closest in dR to a given 
true tau.  The max dR allowed for this truth matching can be
adjusted.

Selectors:

   There are individual selector classes for L1, L2Cal, L2Trk,
as well as EF and the two offline Reco algorithms (to be done).
These place cuts on the quantities contained in the ntuple
to emulate the trigger algorithms at each stage.  The operation
of these selectors is coordinated through the TrigTauSelectionManger,
which has predefined "menus" matching the cuts found in Rel. 12.0.4.

   The setTauMenu function can be used to select a specific menu,
and the cut values can easily be seen from the source code of
this function.  Note that individual selectors are akin to Hypo
algorithms in that they place cuts on a specific object, while
the SelectionManager will also require that previous objects in
a given chain (such as L1) pass a given selection menu.

   For convenience, rudimentary L1 MET cuts have also been
implemented, and this can be expanded into MET menus as the
need arises.  For now, the L1 selection is anded with the L1
MET cut (by default at 0 GeV).

TrigTauAnalyzer:

   To make the three main analysis objects (MCList, ChainList,
and SelectionManager) more convenient to use in ROOT macros,
there is a main analysis class called TrigTauAnalyzer which
contains instances of these three classes.  In a typical analysis
job, there is one TrigTauAnalyzer instantiated, the user sets
the desired MC fiducial cuts and trigger selection menu, then
for each event a pointer to the TrigTauEvent (ntuple) object
is passed to the analyze function.  This fills all the needed
lists (both MC and chain) and the user can then extract any
needed information about the event back out of these two lists.

Example Macros:

   There are several example macros in TrigTauPerformAnalysis/macros.

eventRates.cxx : Simple example which does not use MC Truth.
   For each event, the total number of objects passing at L1 or L2
   are tabulated, in addition to the number of events with at
   least one object passing at each level.  A weight input is 
   provided, so this can be used to plot event rates for backgrounds.

effMultiPlots.cxx : Example of calculating selection efficiency.
   In the event loop, we loop over the Good Taus and look for
   chains passing L1 and L2 within some dR of each good tau.
   This is repeated for each event with several different
   selection menus, and the turn-on curves vs. visible Pt is
   plotted.

resolutionPlots.cxx : Example of looking at resolutions between
   different elements in a chain.  The resolution with respect
   to MC truth, as well as L2 - L1 and EF - L2 (independent
   of MC) are both calculated.  Looking at different tau decay
   modes can be easily done by changing the fiducial cut used
   to fill the MC truth list, selecting, for example, only 
   1-prong decays.