/*
  Copyright (C) 2002-2018 CERN for the benefit of the ATLAS collaboration
*/

/**
 * @file   TRoot2Html.cxx
 * @brief  TRoot2Html implementation
 * @author Frank Winklmeier
 *
 * $Id: TRoot2Html.cxx,v 1.1 2008-07-28 11:02:00 fwinkl Exp $
 */

#include "TrigValTools/TRoot2Html.h"

#include <iostream>
#include <sstream>
#include "TError.h"
#include "TClass.h"
#include "TH1.h"
#include "TFile.h"
#include "TCanvas.h"
#include "TSystem.h"
#include "TKey.h"
#include "TPRegexp.h"

using namespace std;

TRoot2Html::TRoot2Html() :
  m_nodeId(1),
  m_showFullFileName(kFALSE)
{
  setOutputDir("./");
  setImageSize(400,400);
}

TRoot2Html::TRoot2Html(const TRoot2Html& other):
  TMultiFileLooper(other),
  m_imgHeight(other.m_imgHeight),
  m_imgWidth(other.m_imgWidth),
  m_nodeId(other.m_nodeId),
  m_showFullFileName(other.m_showFullFileName)
{
}

void TRoot2Html::beginJob()
{  
   m_xml.open(m_outDir+"/tree.xml");
  if (!m_xml) {
    cout << "Cannot write to directory " << m_outDir << endl;
    return;
  }
  
  m_xml << "<?_xml version='1.0' encoding='iso-8859-1'?>" << endl;
  m_xml << "<!-- This file was auto generated by root2html -->" << endl;
  m_xml << "<!-- Use it with the dhtmlxTree component (http://www.scbr.com/docs/products/dhtmlxTree) -->" << endl;
  m_xml << "<tree id=\"0\">" << endl;
  m_nodeId = 1;
}

void TRoot2Html::endJob()
{
  m_xml << "</tree>" << endl;
  m_xml.close();
}


void TRoot2Html::beforeFile()
{
  TString treeNodeName;
  if (m_showFullFileName) treeNodeName = file()->GetName();
  else treeNodeName = gSystem->BaseName(file()->GetName());
  
  m_xml << "<!-- Start of " << treeNodeName << " -->" << endl;
  m_xml << xmlTreeItem(treeNodeName).Data() << endl;
  
  // Create output directory
  gSystem->mkdir(m_outDir+"/img", true);
}

void TRoot2Html::afterFile()
{
  m_xml << xmlTreeItemClose().Data() << endl;
}


void TRoot2Html::beforeDir()
{
  TString s(getPathFromDir(*gDirectory));
  TString imgDir = TString(m_outDir) + "/img/" + s;
  gSystem->mkdir(imgDir, true);

  m_xml << xmlTreeItem(gDirectory->GetName()).Data() << endl;
}

void TRoot2Html::afterDir()
{
  m_xml << xmlTreeItemClose().Data() << endl;
}


void TRoot2Html::processKey(TDirectory& dir, TKey& key)
{
  dir.cd();
  
  TObject* obj = key.ReadObj();
  if (obj->IsA()->InheritsFrom("TH1")) {
    m_xml << xmlTreeItem(key.GetName()).Data() << endl;
    TString imgPath = hist2Png(*gDirectory, key.GetName());
    if (imgPath!="") {
      m_xml << xmlUserData("img",imgPath).Data() << endl;
    }
    m_xml << xmlTreeItemClose().Data() << endl;
  }
}


// Save histogram 'name' from 'dir' in 'm_outDir/img'
// Return "" on error otherwise image path relative to m_outDir
TString TRoot2Html::hist2Png(TDirectory& dir, const TString& name)
{  
  TH1* h = (TH1*)dir.Get(name);
  if (h==0) {
    cout << "hist2Png: Cannot load histogram " << name << endl;
    return "";
  }
  
  TCanvas c("c","c",m_imgWidth,m_imgHeight);
  TString options(getDrawOptions(*h));
  if (m_verbose) cout << "Drawing histogram " << h->GetName()
                      << " (" << h->ClassName() << ") with options '"
                      << options << "'" << endl;
  h->Draw(options);
  TString s(getPathFromDir(dir));
  TString pngName = "img/" + s + "/" + name + ".png";

  // Suppress the info message when saving file
  Int_t oldIgnoreLevel = gErrorIgnoreLevel;
  if (!m_verbose) gErrorIgnoreLevel = kWarning;
  c.SaveAs(m_outDir+"/"+pngName);

  gErrorIgnoreLevel = oldIgnoreLevel;
  
  return pngName;
}


// Set draw options for all histograms matching re
void TRoot2Html::addDrawOptions(const char* regexp, const char* options)
{
  if (regexp && options) {
    TPRegexp* re = new TPRegexp(regexp);
    if (re) m_drawOptions.push_back(std::pair<TPRegexp*,TString>(re,options));
  }
}

void TRoot2Html::addClassDrawOptions(const char* regexp, const char* options)
{
  if (regexp && options) {
    TPRegexp* re = new TPRegexp(regexp);
    if (re) m_classDrawOptions.push_back(std::pair<TPRegexp*,TString>(re,options));
  }
}


// return draw options for specified histogram
TString TRoot2Html::getDrawOptions(const TH1& h)
{
  TString options("");
  
  // First check if we have class wide draw options for this histogram
  vector< pair<TPRegexp*,TString> >::iterator iter;
  for (iter=m_classDrawOptions.begin(); iter!=m_classDrawOptions.end(); iter++) {
    if (iter->first->Match(h.ClassName())>0) {
      options = iter->second;
      break;
    }
  }
  
  // Check if any regexp matches the histogram name
  for (iter=m_drawOptions.begin(); iter!=m_drawOptions.end(); iter++) {
    if (iter->first->Match(h.GetName())>0) {
      options = iter->second;
      break;
    }
  }
  
  return options;
}

// Tree node with text and id
TString TRoot2Html::xmlTreeItem(const char* text)
{
  TString s;
  s.Form("<item text=\"%s\" id=\"%d\">",text,m_nodeId);
  m_nodeId++;
  return s;
}

// Tree node close
TString TRoot2Html::xmlTreeItemClose()
{
  return "</item>";
}

// User data for tree node
TString TRoot2Html::xmlUserData(const char* name, const char* data)
{
  TString s;
  s.Form("<userdata name=\"%s\">%s</userdata>",name,data);
  return s;
}
