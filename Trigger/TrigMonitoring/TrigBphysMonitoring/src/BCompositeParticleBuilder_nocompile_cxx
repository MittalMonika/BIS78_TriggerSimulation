// ====================================================================
// BCompositeParticleBuilder
// J. Catmore (james.catmore@cern.ch), E. Bouhova-Thacker
// 23rd July 2010
// Code to create a BCompositeParticle from tracks, muons, VxCandidate
// ====================================================================

#include "TrigBphysMonitoring/BCompositeParticleBuilder.h"
#include "muonEvent/MuonContainer.h"
#include "egammaEvent/egammaContainer.h"

#include <sstream>                                      // C++ utilities
#include <string>
#include <algorithm>
#include <fstream>

#include "GaudiKernel/ToolFactory.h"
#include "GaudiKernel/MsgStream.h"
#include "DataModel/DataVector.h"
#include "DataModel/ElementLink.h"
#include "DataModel/DataVector.h"

#include "VxVertex/VxContainer.h"
#include "VxVertex/VxTrackAtVertex.h"
#include "TrkParticleBase/LinkToTrackParticleBase.h"
#include "Particle/TrackParticle.h"
#include "VxVertex/ExtendedVxCandidate.h"

namespace BPhys {

  BCompositeParticleBuilder::BCompositeParticleBuilder(const std::string& t, const std::string& n, const IInterface* p)  : AlgTool(t,n,p),
															   m_V0Tools("Trk::V0Tools")
  {
    declareInterface<BCompositeParticleBuilder>(this);
    declareProperty("V0Tools", m_V0Tools);
    reset();
  }

  StatusCode BCompositeParticleBuilder::initialize() {

    MsgStream msg(msgSvc(), name());

    // get the tool service
    IToolSvc* toolSvc;
    StatusCode sc = service("ToolSvc",toolSvc);
    if (StatusCode::SUCCESS != sc) {
      msg << MSG::ERROR << "Unable to retrieve ToolSvc" << endreq;
      return StatusCode::FAILURE;
    }
    // uploading the V0 tools
    if ( m_V0Tools.retrieve().isFailure() ) {
      msg << MSG::ERROR << "Failed to retrieve tool " << m_V0Tools << endreq;
      return StatusCode::FAILURE;
    } else {
      msg << MSG::DEBUG << "Retrieved tool " << m_V0Tools << endreq;
    }

    return StatusCode::SUCCESS;

  }

  StatusCode BCompositeParticleBuilder::finalize() {

    MsgStream msg(msgSvc(), name());
    msg << MSG::INFO  << "Finalize successful" << endreq;
    return StatusCode::SUCCESS;

  }

  BCompositeParticleBuilder::~BCompositeParticleBuilder() { }

  void BCompositeParticleBuilder::reset(void) {
    m_muons = NULL;
    m_egammas = NULL;
    m_trkMasses.clear();
    m_massHypothesis = -1;
    m_vxCandidate = NULL;
    m_primaryVxs.clear();
  }

  // -----------------------------------------------------------------------------
  // Returns a BCompositeParticle on being given a VxCandidate/ExtendedVxCandidate
  // -----------------------------------------------------------------------------
  // Various options are given. If something is not provided the data member will not be filled.
  // If no mass hypothesis for the represented particle is given the invariant mass of the tracks will be used.

  BCompositeParticle BCompositeParticleBuilder::makeBCompositeParticle(void) {

    std::vector<const Rec::TrackParticle*> theTracks; theTracks.clear();
    BPhys::BCompositeParticle bCompParticle = makeBCompositeParticle(theTracks);
    return bCompParticle;

  }

  BCompositeParticle BCompositeParticleBuilder::makeBCompositeParticle(std::vector<const Rec::TrackParticle*> theTracks) {

    Trk::ExtendedVxCandidate* exvxCandidate = dynamic_cast<Trk::ExtendedVxCandidate* >(m_vxCandidate);
    //bool deleteVx = false;
    if (!exvxCandidate) {
      exvxCandidate = new Trk::ExtendedVxCandidate(m_vxCandidate->recVertex(), *(m_vxCandidate->vxTrackAtVertex()), 0);
      //deleteVx = true;
    }

    // The BCompositeParticle
    BPhys::BCompositeParticle bCompParticle;

    // Check that there is a VxCandidate - minimum requirement
    if (m_vxCandidate==NULL) {
      std::cout << "BCOMPOSITEPARTICLE BUILDER ERROR: NO VXCANDIDATE PROVIDED. RETURNING EMPTY BCOMPOSITEPARTICLE" << std::endl;
      return bCompParticle;
    }
    bCompParticle.setVertex(m_vxCandidate);

    // Count up the tracks
    int nTrks = theTracks.size();
    int nTrkM = m_trkMasses.size();
    if (nTrkM==0) {
      std::cout << "BCOMPOSITEPARTICLE BUILDER ERROR: NO TRACK MASS HYPOTHESES PROVIDED. RETURNING EMPTY BCOMPOSITEPARTICLE" << std::endl;
      return bCompParticle;
    }

    // Fill the tracks immediately if they've been set
    if (nTrks>0) bCompParticle.setTrackParticles(theTracks);
    // if not use the VxCandidate to get the original tracks
    else {
      for (int i=0; i<nTrkM; ++i) {
	const Trk::TrackParticleBase* origTrkTmp = m_V0Tools->origTrackPB(exvxCandidate,i);
	const Rec::TrackParticle* origTPTmp = dynamic_cast<const Rec::TrackParticle*>(origTrkTmp);
	theTracks.push_back(origTPTmp);
      }
      bCompParticle.setTrackParticles(theTracks);
    }

    // Loop over the tracks and set the charge
    int nSetTracks = bCompParticle.trackParticles().size();
    int summedCharge(0);	
    for (int i=0; i<nSetTracks; ++i) {
	double qOverP = bCompParticle.trackParticle(i)->measuredPerigee()->parameters()[Trk::qOverP];
	if (qOverP < 0.0) summedCharge = summedCharge - 1;
	if (qOverP > 0.0) summedCharge = summedCharge + 1;
    }
    bCompParticle.setCharge(summedCharge);

    // If user has set muons/egammas, match to tracks and add
    std::vector<const Analysis::Muon*> theMuons;
    std::vector<const egamma*> theEgammas;
    if ( (m_muons!=NULL) || (m_egammas!=NULL) ) {
      std::vector<const Rec::TrackParticle*>::const_iterator trkItr;
      for (trkItr=theTracks.begin(); trkItr!=theTracks.end(); ++trkItr) {
	if (m_muons!=NULL) {
	  Analysis::MuonContainer::const_iterator muItr;
	  for (muItr=m_muons->begin(); muItr!=m_muons->end(); ++muItr) {
	    if ( ( (*muItr)->inDetTrackParticle()==*trkItr) || ((*muItr)->combinedMuonTrackParticle()==*trkItr) ) {
	      theMuons.push_back(*muItr);
	      break;
	    }
	  }
	}
	if (m_egammas!=NULL) {
	  egammaContainer::const_iterator eItr;
	  for (eItr=m_egammas->begin(); eItr!=m_egammas->end(); ++eItr) {
	    if ( (*eItr)->trackParticle()==*trkItr ) {
	      theEgammas.push_back(*eItr);
	      break;
	    }
	  }
	}
      } // end of loop over tracks
      bCompParticle.setMuons(theMuons);
      bCompParticle.setEgammas(theEgammas);
    }

    // Invariant masses and their errors, fit chi2 and ndf
    double mass = m_V0Tools->invariantMass(exvxCandidate,m_trkMasses);
    bCompParticle.setRefittedMass(mass);
    double error = m_V0Tools->invariantMassError(exvxCandidate,m_trkMasses);
    bCompParticle.setRefittedMassError(error);
    bCompParticle.setChi2(m_V0Tools->chisq(exvxCandidate));
    bCompParticle.setNDoF(m_V0Tools->ndof(exvxCandidate));
    // V0 candidate momentum, using invariant mass calculated from daughters.
    double pt = m_V0Tools->pT(exvxCandidate);
    bCompParticle.setRefittedPt(pt);
    double ptError = m_V0Tools->pTError(exvxCandidate);
    bCompParticle.setRefittedPtError(ptError);
    CLHEP::HepLorentzVector p, ptable;
    if (m_massHypothesis == -1.0) {
	ptable.setPx(0.0);
        ptable.setPy(0.0);
        ptable.setPz(0.0);
        ptable.setE(0.0);
    }
    else ptable = m_V0Tools->V04Momentum(exvxCandidate,m_massHypothesis);
    p = m_V0Tools->V04Momentum(exvxCandidate,mass);
    bCompParticle.setRefittedP(p);
    bCompParticle.setRefittedPMassHypothesis(ptable);

    // Lxy, pseudo-proper decay time and errors, cos(theta)
    // Store refitted primary vertices
    std::vector<Trk::VxCandidate*>::iterator pvItr;
    std::vector<double> lxy,lxyError,tau,tauError,chi2PerDoF;
    std::vector<double> tauTable,tauErrorTable;
    std::vector<double> tauCorrected,tauErrorCorrected;
    std::vector<double> cosTheta, cosThetaXY;
    std::vector<double> a0,a0Error,a0xy,a0xyError;
    std::vector<double> massTauCov;
    std::vector<CLHEP::Hep3Vector> refPVsPos;
    std::vector<CLHEP::HepMatrix> refPVsHM;
    for (pvItr=m_primaryVxs.begin(); pvItr!=m_primaryVxs.end(); ++pvItr) {
      // Lxy and Lxy Error
      lxy.push_back(m_V0Tools->lxy(exvxCandidate, (*pvItr)->recVertex()) );
      lxyError.push_back(m_V0Tools->lxyError(exvxCandidate, (*pvItr)->recVertex()) );
      // pseudo-proper decay time and error
      if (m_massHypothesis == -1.0) {
	tauTable.push_back(-99999.0);
	tauCorrected.push_back(-99999.0);
      }
      else {
	tauTable.push_back(m_V0Tools->tau(exvxCandidate, (*pvItr)->recVertex(), m_massHypothesis) );
	tauCorrected.push_back( m_V0Tools->tau(exvxCandidate, (*pvItr)->recVertex(), m_trkMasses, m_massHypothesis)  );
      }
      tau.push_back(m_V0Tools->tau(exvxCandidate, (*pvItr)->recVertex(), m_trkMasses) );
      if (m_massHypothesis == -1.0) {
	tauErrorTable.push_back(-99999.0);
	tauErrorCorrected.push_back(-99999.0);
      }
      else {
	tauErrorTable.push_back(m_V0Tools->tauError(exvxCandidate, (*pvItr)->recVertex(), m_massHypothesis) );
	tauErrorCorrected.push_back(m_V0Tools->tauError(exvxCandidate, (*pvItr)->recVertex(), m_trkMasses, m_massHypothesis) );
      }
      tauError.push_back(m_V0Tools->tauError(exvxCandidate, (*pvItr)->recVertex(), m_trkMasses) );
      // Cos theta
      cosTheta.push_back(m_V0Tools->cosTheta(exvxCandidate, (*pvItr)->recVertex()));
      cosThetaXY.push_back(m_V0Tools->cosTheta_xy(exvxCandidate, (*pvItr)->recVertex()));

      // B-momentum impact parameter
      a0.push_back(m_V0Tools->a0(exvxCandidate, (*pvItr)->recVertex()) );
      if(a0.back()!=0)
        a0Error.push_back(m_V0Tools->a0Error(exvxCandidate, (*pvItr)->recVertex()) );
      else
        a0Error.push_back( -99999.0 );

      a0xy.push_back(m_V0Tools->a0xy(exvxCandidate, (*pvItr)->recVertex()) );
      if(a0xy.back()!=0)
        a0xyError.push_back(m_V0Tools->a0xyError(exvxCandidate, (*pvItr)->recVertex()) );
      else
        a0xyError.push_back( -99999.0 );

      // Mass-tau correlation term
      massTauCov.push_back(m_V0Tools->massTauCov(exvxCandidate,(*pvItr)->recVertex(), m_trkMasses));
    }

    // Polarization angles; only relevant to J/psi
    double thetaStar, cosThetaStar, phiStar;
    if (nTrkM==2) {
	thetaStar = m_V0Tools->thetaStar(exvxCandidate, m_trkMasses[0], m_trkMasses[1]);
	cosThetaStar = m_V0Tools->cosThetaStar(exvxCandidate, m_trkMasses[0], m_trkMasses[1]);
	phiStar = m_V0Tools->phiStar(exvxCandidate);
    } else {
	thetaStar = -99999.0;
	cosThetaStar = -99999.0;
	phiStar = -99999.0;
    }

    // Fill the composite particle......

    bCompParticle.setLxy(lxy);
    bCompParticle.setLxyError(lxyError);
    bCompParticle.setTauCorrected(tauCorrected);
    bCompParticle.setTauMassHypothesis(tauTable);
    bCompParticle.setTau(tau);
    bCompParticle.setTauErrorCorrected(tauErrorCorrected);
    bCompParticle.setTauErrorMassHypothesis(tauErrorTable);
    bCompParticle.setTauError(tauError);
    bCompParticle.setCosTheta(cosTheta);
    bCompParticle.setCosThetaXY(cosThetaXY);
    bCompParticle.setA0(a0);
    bCompParticle.setA0Error(a0Error);
    bCompParticle.setA0xy(a0xy);
    bCompParticle.setA0xyError(a0xyError);
    bCompParticle.setPrimaryVertices(m_primaryVxs);
    bCompParticle.setThetaStar(thetaStar);
    bCompParticle.setCosThetaStar(cosThetaStar);
    bCompParticle.setPhiStar(phiStar);
    bCompParticle.setMassTauCov(massTauCov);

    // Refitted tracks
    std::vector<CLHEP::HepLorentzVector> trksAtVtx;
    for (int i=0; i<nTrkM; ++i) {
      CLHEP::HepLorentzVector tmpHLV;
      CLHEP::Hep3Vector tmp3vect(m_V0Tools->trackMomentum(exvxCandidate,i)[0],
                                 m_V0Tools->trackMomentum(exvxCandidate,i)[1],
                                 m_V0Tools->trackMomentum(exvxCandidate,i)[2]);
      tmpHLV.setVectM(tmp3vect,m_trkMasses.at(i) );
      trksAtVtx.push_back(tmpHLV);
    }
    bCompParticle.setTracksAtVertex(trksAtVtx);

    //vertex position and error
    bCompParticle.setX(m_V0Tools->vtx(exvxCandidate).x());
    bCompParticle.setY(m_V0Tools->vtx(exvxCandidate).y());
    bCompParticle.setZ(m_V0Tools->vtx(exvxCandidate).z());

    // covariance
    Amg::MatrixX hm(3,3);
    hm(0,0) = exvxCandidate->recVertex().covariancePosition()(0,0);
    hm(0,1) = exvxCandidate->recVertex().covariancePosition()(0,1);
    hm(0,2) = exvxCandidate->recVertex().covariancePosition()(0,2);
    hm(1,0) = exvxCandidate->recVertex().covariancePosition()(1,0);
    hm(1,1) = exvxCandidate->recVertex().covariancePosition()(1,1);
    hm(1,2) = exvxCandidate->recVertex().covariancePosition()(1,2);
    hm(2,0) = exvxCandidate->recVertex().covariancePosition()(2,0);
    hm(2,1) = exvxCandidate->recVertex().covariancePosition()(2,1);
    hm(2,2) = exvxCandidate->recVertex().covariancePosition()(2,2);
      
      
    bCompParticle.setPositionCovarianceMatrix(hm);
    bCompParticle.setCompleteCovariance(exvxCandidate->fullCovariance());

    //if(deleteVx) delete exvxCandidate;
    return bCompParticle;

  }

} // End of namespace
