#ifndef BPHYSCOMPOSITEPARTICLE_H
#define BPHYSCOMPOSITEPARTICLE_H
#include "CLHEP/Vector/LorentzVector.h"
//#include "CLHEP/Matrix/Matrix.h"
//#include "TrkEventPrimitives/CovarianceMatrix.h"
#include "EventPrimitives/EventPrimitives.h"

#include <vector>
#include <string>

namespace HepMC {class GenParticle;}
namespace Rec   {class TrackParticle;}
namespace Analysis {class Muon;}
namespace Trk {class VxCandidate;}
class egamma;

namespace BPhys {

  class BCompositeParticle {

  public:

    BCompositeParticle();
    // Tracks
    std::vector<const Rec::TrackParticle*> trackParticles(void) {return m_tracks;}
    const Rec::TrackParticle* trackParticle(unsigned int i);
    void setTrackParticles(std::vector<const Rec::TrackParticle*> trksIn) {m_tracks=trksIn;}
    void addTrackParticle(const Rec::TrackParticle* trkIn) {m_tracks.push_back(trkIn);}
    // Muons
    std::vector<const Analysis::Muon*> muons(void) {return m_muons;}
    const Analysis::Muon* muon(unsigned int i);
    void setMuons(std::vector<const Analysis::Muon*> muonsIn) {m_muons=muonsIn;}
    void addMuon(const Analysis::Muon* muonIn) {m_muons.push_back(muonIn);}
    // Electrons/photos
    std::vector<const egamma*> egammas(void) {return m_egammas;}
    const egamma* getEgamma(unsigned int i);
    void setEgammas(std::vector<const egamma*> egammasIn) {m_egammas=egammasIn; }
    void addEgamma(const egamma* egammaIn) {m_egammas.push_back(egammaIn); }
    // Other composite particles
    std::vector<BCompositeParticle*> constituents(void) {return m_cons;}
    BCompositeParticle* constituent(unsigned int i);
    void addConstituent(BCompositeParticle* pIn) {m_cons.push_back(pIn); } 
    // Cascade constituents (not used for any internal calculations)
    std::vector<BCompositeParticle*> cascadeConstituents(void) {return m_casc;}
    BCompositeParticle* cascadeConstituent(unsigned int i);
    void addCascadeConstituent(BCompositeParticle* pIn) {m_casc.push_back(pIn);}
    // Vertex
    Trk::VxCandidate* vertex(void) {return m_vertex;}
    void setVertex(Trk::VxCandidate* vertexIn) {m_vertex = vertexIn;}
    // Truth
    const HepMC::GenParticle* truthParticle(void) {return m_truth;}
    void setTruthParticle(const HepMC::GenParticle* tpIn) {m_truth = tpIn;}
    // Charge
    int charge(void) {return m_charge;}
    void setCharge(int chargeIn) {m_charge = chargeIn;} 
    // Labelling
    std::string label(void) {return m_label;}
    void setLabel(std::string stringIn) {m_label = stringIn;}
    void setSignal(bool boolIn) {m_isSignal = boolIn;}
    bool isSignal(void) {return m_isSignal;}
    // Indices
    void setIndex(int indexIn) {m_index = indexIn;}
    int index(void) {return m_index;}
    // void setParentIndex(int indexIn) {m_parentIndex = indexIn;}
    // int parentIndex(void) {return m_parentIndex;}
    void addChildIndex(int indexIn) {m_childrenIndices.push_back(indexIn);}
    void setChildIndices(std::vector<int> indicesIn) {m_childrenIndices = indicesIn;}
    int childIndex(int index) {return m_childrenIndices[index];}
    std::vector<int> childrenIndices(void) {return m_childrenIndices;}

    // Quantities derived from the VxCandidate
    // TracksAtVertex
    void setTracksAtVertex(std::vector<CLHEP::HepLorentzVector> trksAtVtx) {m_trksAtVtx = trksAtVtx;}
    std::vector<CLHEP::HepLorentzVector> tracksAtVertex(void) {return m_trksAtVtx;}
    CLHEP::HepLorentzVector trackAtVertex(unsigned int i);
    // Mass after vertexing
    double refittedMass(void) {return m_refittedMass;}
    void setRefittedMass(double refittedMass) {m_refittedMass = refittedMass;}
    double refittedMassError(void) {return m_refittedMassError;}
    void setRefittedMassError(double refittedMassError) {m_refittedMassError = refittedMassError;}
    // P after vertexing
    CLHEP::HepLorentzVector refittedP(void) {return m_refittedP;}
    void setRefittedP(CLHEP::HepLorentzVector refittedP) {m_refittedP = refittedP;}
    CLHEP::HepLorentzVector refittedPMassHypothesis(void) {return m_refittedPMH;}
    void setRefittedPMassHypothesis(CLHEP::HepLorentzVector refittedPMH) {m_refittedPMH = refittedPMH;}
    // Pt after vertexing
    double refittedPt(void) {return m_refittedPt;}
    void setRefittedPt(double refittedPt) {m_refittedPt = refittedPt;}
    double refittedPtError(void) {return m_refittedPtError;}
    void setRefittedPtError(double refittedPtError) {m_refittedPtError = refittedPtError;}
    // Vertex position
    double x(void) {return m_x;}
    void setX(double x) {m_x = x;}
    double y(void) {return m_y;}
    void setY(double y) {m_y = y;}
    double z(void) {return m_z;}
    void setZ(double z) {m_z = z;}
    // Vertex position covariance matrix
    Amg::MatrixX positionCovarianceMatrix(void) {return m_positionCovarianceMatrix;}
    void setPositionCovarianceMatrix(Amg::MatrixX positionCovarianceMatrix) {m_positionCovarianceMatrix = positionCovarianceMatrix;}
    // Complete covariance matrix
    Amg::MatrixX completeCovariance(void) {return m_completeCovariance;}
    void setCompleteCovariance(const Amg::MatrixX *completeCovariance) {m_completeCovariance = *completeCovariance;} 
    // Chi2 and nDoF
    double chi2(void) {return m_chi2;}
    void setChi2(double chi2) {m_chi2 = chi2;}
    int nDoF(void) {return m_nDoF;}
    void setNDoF(double nDoF) {m_nDoF = nDoF;}
    // Lxy and LxyError - value is a vector in case of ambiguity on primary vertex
    std::vector<double> lxy(void) {return m_lxy;}
    void setLxy(std::vector<double> lxy) {m_lxy = lxy;}
    std::vector<double> lxyError(void) {return m_lxyError;}
    void setLxyError(std::vector<double> lxyError) {m_lxyError = lxyError;}  
    // Proper decay time - value is a vector in case of ambiguity on primary vertex
    std::vector<double> tau(void) {return m_tau;}
    void setTau(std::vector<double> tau) {m_tau = tau;}
    std::vector<double> tauMassHypothesis(void) {return m_tauMH;}
    void setTauMassHypothesis(std::vector<double> tauMH) {m_tauMH = tauMH;}
    std::vector<double> tauErrorMassHypothesis(void) {return m_tauErrorMH;}
    void setTauErrorMassHypothesis(std::vector<double> tauErrorMH) {m_tauErrorMH = tauErrorMH;}
    std::vector<double> tauError(void) {return m_tauError;}
    void setTauError(std::vector<double> tauError) {m_tauError = tauError;}    
    std::vector<double> tauCorrected(void) {return m_tauCorr;}
    void setTauCorrected(std::vector<double> tauCorrIn) {m_tauCorr=tauCorrIn;}
    std::vector<double> tauErrorCorrected(void) {return m_tauErrorCorr;}
    void setTauErrorCorrected(std::vector<double> tauErrorCorrIn) {m_tauErrorCorr=tauErrorCorrIn;}
    // cos(angle) between line from primary vertex and resultant
    std::vector<double> cosTheta(void) {return m_cosTheta;}
    void setCosTheta(std::vector<double> cosTheta) {m_cosTheta = cosTheta;}
    // As above in transverse plane
    std::vector<double> cosThetaXY(void) {return m_cosThetaXY;}
    void setCosThetaXY(std::vector<double> cosThetaXY) {m_cosThetaXY = cosThetaXY;}
    // Closest passing of B-momentum by the primary vertex (~B-momentum impact parameter)
    std::vector<double> a0(void) {return m_a0;}
    void setA0(std::vector<double> a0) {m_a0 = a0;}
    std::vector<double> a0Error(void) {return m_a0Error;}
    void setA0Error(std::vector<double> a0Error) {m_a0Error = a0Error;}
    // Closest passing of B-momentum by the primary vertex (transverse plane only)
    std::vector<double> a0xy(void) {return m_a0xy;}
    void setA0xy(std::vector<double> a0xy) {m_a0xy = a0xy;}
    std::vector<double> a0xyError(void) {return m_a0xyError;}
    void setA0xyError(std::vector<double> a0xyError) {m_a0xyError = a0xyError;}
    // Polarization angles (only relevant to J/psi)	
    double thetaStar(void) {return m_thetaStar;}
    double cosThetaStar(void) {return m_cosThetaStar;}
    double phiStar(void) {return m_phiStar;}
    void setThetaStar(double thetaStar) {m_thetaStar = thetaStar;}
    void setCosThetaStar(double cosThetaStar) {m_cosThetaStar = cosThetaStar;}
    void setPhiStar(double phiStar) {m_phiStar = phiStar;}
    // Mass-tau covariance term
    std::vector<double> massTauCov(void) {return m_massTauCov;}
    void setMassTauCov(std::vector<double> massTauCov) {m_massTauCov = massTauCov;}
    // Primary vertex(-ices) 
    std::vector<Trk::VxCandidate*> primaryVertices(void) {return m_PV;}
    void setPrimaryVertices(std::vector<Trk::VxCandidate*> primaryVertices) {m_PV = primaryVertices;}

    // Fast access 
    double refittedPx(void);
    double refittedPy(void);
    double refittedPz(void);
    double refittedE(void);
    double refittedPseudorapidity(void); 

    std::vector<const Rec::TrackParticle*> AllTrackParticles();


  private: 

    // Reconstructed components
    std::vector<const Rec::TrackParticle*> m_tracks; 
    std::vector<const Analysis::Muon*> m_muons;
    std::vector<const egamma*> m_egammas;
    // Result of vertex fit
    Trk::VxCandidate* m_vertex;
    // Constituent composite particle
    std::vector<BCompositeParticle*> m_cons;
    std::vector<BCompositeParticle*> m_casc;
    // Truth particle and signal label
    const HepMC::GenParticle* m_truth;
    bool m_isSignal;
    // Charge, indices, label
    int m_charge, m_index; //parentIndex;
    std::vector<int> m_childrenIndices;
    std::string m_label;
    // Mass and error from VxCandidate
    double m_refittedMass; double m_refittedMassError;
    // Momentum from VxCandidate
    CLHEP::HepLorentzVector m_refittedP;
    CLHEP::HepLorentzVector m_refittedPMH;
    // Tracks refitted by vertexing
    std::vector<CLHEP::HepLorentzVector> m_trksAtVtx;
    // Pt from VxCandidate
    double m_refittedPt; double m_refittedPtError;
    // Position from VxCandidate
    double m_x; double m_y; double m_z;
    // Position covariance matrix from VxCandidate
    Amg::MatrixX m_positionCovarianceMatrix;
    // Complete covariance
    Amg::MatrixX m_completeCovariance;  
    // Chi2 and number of degrees of freedom from VxCandidate
    double m_chi2; int m_nDoF;
    // Lxy and error from VxCandidate and the refitted primary vertex(ices)
    std::vector<double> m_lxy; std::vector<double> m_lxyError;
    // Pseudoproper decay time from VxCandidate and the refitted primary vertex(ices)
    std::vector<double> m_tau; std::vector<double> m_tauError;
    std::vector<double> m_tauMH, m_tauErrorMH;
    std::vector<double> m_tauCorr, m_tauErrorCorr;
    // cos(angle) between line from PV and resultant
    std::vector<double> m_cosTheta; std::vector<double> m_cosThetaXY;  
    // a0 and error from VxCandidate and the refitted primary vertex(ices)
    std::vector<double> m_a0; std::vector<double> m_a0Error;
    std::vector<double> m_a0xy; std::vector<double> m_a0xyError;
    // Polarization angles
    double m_thetaStar, m_cosThetaStar, m_phiStar;
    // Mass-tau covariance term
    std::vector<double> m_massTauCov;
    // Primary vertex(-ices)
    std::vector<Trk::VxCandidate*> m_PV;

    std::vector<BCompositeParticle*> LoopCompositeParticles(std::vector<BPhys::BCompositeParticle*>);

  };

}  // end of namespace 
#endif

