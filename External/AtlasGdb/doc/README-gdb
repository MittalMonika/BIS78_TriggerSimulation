This is gdb 7.2sss1, built for linux.
Taken from the gnu distribution.

This version of gdb has several local changes (patches are all in kitting/):

 - cintex.diff: Allows gdb to dump a stack backtrace past cintex trampolines.
   Likely to only work for 32 bit programs.

 - heap-commands.diff: Adds `sheap' and `sheapf' commands for dumping
   the malloc heap.  This functionality is specific to the default malloc
   in the linux libc; it is not likely to work with other mallocs.
   Likely to only work for 32 bit programs.
   See below for more details.

 - objfile_hook.diff: This adds a new hook, gdb.objfile_hook.
   If this is bound to a callable object, it will be called
   when an objfile is loaded, after the standard python autoloads
   are done.  The function will get the objfile as an argument.

 - pyinput.diff: Adds a new python function gdb.input.  This reads a line
   of input from the user.

 - python23.diff: Allows building with python 2.3 (as on slc4).

 - ctrl-c.diff: Allows ctrl-c to interrupt python code.

 - version.diff: Update the gdb version string.


Compared to gdb-7.0sss2, the function gdb.execute_getoutput() has been removed;
its functionality is now available through the standard execute() function.
Also, the heap and heapf commands have been renamed to sheap and sheapf,
anticipating the inclusion of the more comprehensive heap command from Fedora.


I've started to put together a collection of gdb macros and functions
useful for Atlas.  See the latest tag of $SVNUSR/ssnyder/gdbhacks.


Heap dump commands
==================

This version of gdb has been patched to include a command for scanning
the malloc heap.  This functionality is specific to the default malloc
in the linux libc; it is not likely to work with other mallocs.

Use the command

  sheap <begin> <end>

where <begin> and <end> are addresses.  The command will scan between
these two addresses, looking for a free block in the heap.  Once
it finds one, it will start dumping out blocks in the heap.

Here's an example of the output:

0x11ccd348: FREE 0x6d20 -> 0x107dc240:  0x00006d68
0x11cd4068: USED 0x18 -> 0x471f9fdc:    0x5f737063
0x11cd4080: USED 0xe8 -> 0x43133d68 <main_arena+232>:   0x43133d60
0x11cd4168: USED 0x20 -> 0x478c7bd4:    0x5f737063
0x11cd4188: USED 0x20 -> 0x47be52f4:    0x5f737063
0x11cd41a8: USED 0x18 -> 0x4639aa6c:    0x5f737063
0x11cd41c0: USED 0x38 -> 0xab84c88 <_ZTVN3fwk12HistoryChunkE+8>:        0x09c74c6e
0x11cd41f8: USED 0x808
0x11cd4a00: USED 0x28 -> 0xab7ef28 <_ZTVN7d0om_DS6ObjectE+8>:   0x09a84d94
0x11cd4a28: USED 0x28 -> 0xf966a58:     0x0ab7ed08
0x11cd4a50: FREE 0x668 -> 0x107e9288:   0x00000000
0x11cd50b8: USED 0x418 -> 0xab7da40 <_ZTVN7d0om_DS4SrefE+8>:    0x09a5f65e
0x11cd54d0: USED 0x418 -> 0xab7da40 <_ZTVN7d0om_DS4SrefE+8>:    0x09a5f65e
0x11cd58e8: USED 0x808


First column is the starting address of the block.  (This is the address
that's returned to the user from malloc.)  Next is the block status,
either FREE or USED.  Next is the block size, in bytes.  We then
take the first word in the block, interpret it as an address,
and examine that address.  If gcc 3+ is used, then if the block
contains an object with a vtable, the first word is the vtable
pointer, so this will show you the type of the object (ok, what
you actually get shown is the mangled name of the object's
vtable).  For all other types of blocks, this information is not
usually useful.  Note that this doesn't work for KCC (or gcc v2),
as the vtable pointer is not at a fixed location in the object.
(In such cases, however, one can often dump out the first ten or so
longwords of the object and examine any that look like they might
be vtable addresses.)

There are several things to be aware of when using this.

First, there is no reliable way of finding the block boundaries, given
just the memory containing the blocks.  The implementation here uses
a heuristic to try to locate free blocks.  This works reasonably well,
but it can be fooled into thinking that it has found a free block
when it is really in the middle of a block.  Note that the libc
allocator will usually not have adjacent FREE blocks; if you see
this in the output, then this has probably happened.  Restarting
the scan at a different address may help.

Second, while one can come up with some rules that will identify
free blocks, it is difficult to reliably identify used blocks in the
middle of the heap.  That is why the behavior of the heap command
is to first scan for a free block and start dumping from there.
If the address range you give to the heap command is entirely
used, containing no free blocks, then it will produce no output
(assuming it doesn't falsely identify a free block as above).
If you think you know the starting address of a block in the heap,
you can force the command to start dumping at that address by using
the command `sheapf' instead of `sheap'.

Third, keep in mind that the linux libc allocates memory in two ways.
Small allocations are made on the heap (extended via sbrk).  This grows
and shrinks in a stack-like fashion.  Large allocations may be done
individually using mmap; these can also be freed individually.
(There is a limit on how many of these blocks can be allocated;
once that's used up, the allocator reverts to allocating from the heap.
And i think this strategy is used only if there isn't already room
in the heap for the block.)  Allocations of the second type will not
be seen by the heap command since they live in a different address
range (and they don't have the control information to identify
them as malloc blocks).

Fourth, also keep in mind that some C++ code uses its own allocators
built on top of malloc.  The STL containers as implemented by gcc
are examples of this.  What you'll see in the heap is the large bulk
allocations made by these allocators, not the individual allocations
for the C++ objects.  Often, these bulk allocations end up in mmap'd
space, so they're not visible at all to the heap command.

Even with these caveats, this is sometimes useful for identifying
memory leaks.  Here's an outline of a strategy using it.

On linux, you can find the memory map for a process <pid> by reading
the pseudo-file /proc/<pid>/maps.  So, start the program you want
to investigate.  Let it get safely past the initialization.
Make a copy of the memory map file.  Let the process run for a while
more.  Make another copy of the memory map.  Attach to the process
with a debugger.  Then compare the two memory maps.  Here's an example:


 08048000-0a7f5000 r-xp 00000000 3a:02 11682064   /work/shoreham-clued0/snyder/trigsim/trigsim/bin/Linux2.4-GCC_3_1/D0TrigSim_x
 0a7f5000-0b364000 rw-p 027ad000 3a:02 11682064   /work/shoreham-clued0/snyder/trigsim/trigsim/bin/Linux2.4-GCC_3_1/D0TrigSim_x
-0b364000-11b4a000 rwxp 00000000 00:00 0
+0b364000-12385000 rwxp 00000000 00:00 0
 40000000-40015000 r-xp 00000000 03:01 448393     /lib/ld-2.2.4.so
 40015000-40016000 rw-p 00014000 03:01 448393     /lib/ld-2.2.4.so
 40016000-40017000 rw-p 00000000 00:00 0
@@ -165,13 +165,16 @@
 43467000-434a4000 r-xp 00000000 03:01 255144     /usr/lib/libdb2.so.3
 434a4000-434a5000 rw-p 0003c000 03:01 255144     /usr/lib/libdb2.so.3
 434a5000-43cab000 rw-p 00000000 00:00 0
-43ccb000-43cde000 rw-p 00826000 00:00 0
-43d06000-4511c000 rw-p 00861000 00:00 0
-4515c000-4678a000 rw-p 01cb7000 00:00 0
+43ccb000-43cff000 rw-p 00826000 00:00 0
+43d06000-4513d000 rw-p 00861000 00:00 0
+4515c000-467cc000 rw-p 01cb7000 00:00 0
 467d3000-4689d000 rw-p 0332e000 00:00 0

The first difference is the heap area.  The end of the heap has expanded
from 0x11b4a000 to 0x12385000.  The differences further down, in the
0x4... address range, are mmap'd blocks.

If the program was finished initializing at the time we took the first
snapshot, and was steadily leaking memory for a while before we took
the second snapshot, then it is likely that the area around the
end of the heap in the first snapshot will contain mostly leaked
objects.  So dump out the heap around that address and try to see
what objects are there.

This can also help to identify heap fragmentation.  Look for large
FREE blocks separated by small USED blocks.

Unfortunately, this will not tell you from where in the code
a given memory block was allocated.  However, if you also use
a tool such as memprof, it is possible to extract this information
from there.


sss
Nov, 2010
