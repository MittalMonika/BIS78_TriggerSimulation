/*
  Copyright (C) 2002-2019 CERN for the benefit of the ATLAS collaboration
*/




// local includes
#include "GeoWrite/DumpGeoModelAction.h"

// TFPersistification includes
#include "TFPersistification/TransFunctionPersistifier.h"


// GeoModelKernel includes
#include "GeoModelKernel/GeoNodePath.h"
#include "GeoModelKernel/GeoCountVolAction.h"
// GeoModelKernel shapes
#include "GeoModelKernel/GeoBox.h"
#include "GeoModelKernel/GeoCons.h"
#include "GeoModelKernel/GeoPara.h"
#include "GeoModelKernel/GeoPcon.h"
#include "GeoModelKernel/GeoPgon.h"
#include "GeoModelKernel/GeoSimplePolygonBrep.h"
#include "GeoModelKernel/GeoShapeShift.h"
#include "GeoModelKernel/GeoTrap.h"
#include "GeoModelKernel/GeoTrd.h"
#include "GeoModelKernel/GeoTube.h"
#include "GeoModelKernel/GeoTubs.h"

// CLHEP includes
#include "CLHEP/Geometry/Transform3D.h"
#include "CLHEP/Matrix/SymMatrix.h"
#include "CLHEP/Matrix/Matrix.h"



// Qt includes
#include <QSqlQuery>
#include <QSqlError>
#include <QSqlRecord>
#include <QSqlDriver>
#include <QVector>
#include <QDebug>

// C++ includes
#include <sstream>



int DumpGeoModelAction::getChildPosition(unsigned int parentId)
{
	if ( ! (m_parentChildrenMap.contains(parentId)) ) {
		m_parentChildrenMap[parentId] = 0;
	}
	++m_parentChildrenMap[parentId];
	return m_parentChildrenMap[parentId];
}


void DumpGeoModelAction::handlePhysVol (const GeoPhysVol *vol)
{
	qDebug() << "\nDumpGeoModelAction::handlePhysVol(GeoPhysVol*)";
	handleVPhysVolObjects( vol );
}


void DumpGeoModelAction::handleFullPhysVol (const GeoFullPhysVol *vol)
{
	qDebug() << "\nDumpGeoModelAction::handleFullPhysVol( GeoFullPhysVol* )";
	handleVPhysVolObjects( vol );
}


void DumpGeoModelAction::handleVPhysVolObjects(const GeoVPhysVol* vol)
{
	qDebug() << "\nDumpGeoModelAction::handleVPhysVolObjects( GeoVPhysVol* )";


	// get the address string for the current volume
	QString address = getAddressStringFromPointer( vol );

	// variables used to persistify the object
	QVariant parentId;
	QVariant physId;

	// check the volume position in the geometry tree
	GeoNodePath* path = getPath();
	unsigned int len = path->getLength();
	qDebug() << "length: " << len;
	//	std::cout << "path: " << path << std::endl;

	const GeoVPhysVol* parentNode = nullptr;

	// this below is performed until the root volume is found, then "length" is not used anymore,
	// because not updated when recursively visiting PhysVols
	bool getParentNode = true;
	bool storeRootVolume = false;
	if ( ! m_rootVolumeFound) {
		if (len > 1) {
			getParentNode = true;
		} else{
			qDebug() << "This is the Root volume!";
			m_rootVolumeFound = true;
			storeRootVolume = true;
			getParentNode = false;
		}
	} else {
		getParentNode = true;
	}

	// get the parent volume, if this is not the Root volume
	if (getParentNode) {

		parentNode = dynamic_cast<const GeoVPhysVol*>( &(*(vol->getParent() )));

		if (parentNode) {
			QString parentAddress = getAddressStringFromPointer(parentNode);
			qDebug() << "parent's address:" << parentNode;

			if (isAddressStored(parentAddress))
				parentId = getStoredIdFromAddress(parentAddress);
			//		else
			//			qFatal("FATAL ERROR!!! - The parent node of this child should has been stored in the DB already, but it was not found!!");

			qDebug() << "parent's LogVol name:" << QString::fromStdString(parentNode->getLogVol()->getName());
		}
		else {
			qDebug() << "NULL parent node!!";
		}
	}

	// counting children
	unsigned int nChildren = vol->getNChildVols();
	qDebug() << "number of child physical volumes:" << nChildren;
	qDebug() << "[number of PhysVol and SerialTransformer child nodes:" << vol->getNChildVolAndST() << "]";

	//// for debug
	// GeoCountVolAction cv;
	// cv.setDepthLimit(1);
	// vol->exec(&cv);
	// int nChildCount = cv.getCount();
	// qDebug() << "number of child volumes:" << nChildCount;



	// check if this object has been stored already
	if (! isAddressStored(address)) {

		/*
		 * VPhysVol features:
		 * - 1 parent VPhysVol (if any)
		 * - 1 LogVol
		 * - 1 Material
		 * - 1 Shape
		 */

		// Note: PhysVol has no name. Its LogVol has a name.
		//	  const std::string name = vol->getLogVol()->getName();

		// LOGVOL
		const GeoLogVol* logVol = vol->getLogVol();
		const QString logName = QString::fromStdString(logVol->getName());
		qDebug() << "LogVol name:"  << logName;


		// MATERIAL
		const GeoMaterial * mat = vol->getLogVol()->getMaterial();
		const QString matName = QString::fromStdString(mat->getName());
		qDebug() << "material name:" << matName << ", address:" << mat;


		// SHAPE
		const GeoShape * shape = vol->getLogVol()->getShape();
		// const QString shapeType = QString::fromStdString(shape->type());
		// qDebug() << "shape name:" << shapeType  << ", address:" << shape;
		// // get shape parameters
		// QString shapePars = getShapeParameters(shape);


		/*
		 * STORE THE OBJECTS IN THE DB
		 */

		// store/get the Material object into/from the DB
		QVariant matId;
		matId = storeObj(mat, matName);

		// store/get the Shape object into/from the DB
		QVariant shapeId;
		shapeId = storeShape(shape);
		// shapeId = storeObj(shape, shapeType, shapePars);

		// store/get the LogVol object into/from the DB
		QVariant logvolId;
		logvolId = storeObj(logVol, logName, shapeId, matId);

		if (dynamic_cast<const GeoPhysVol*>(vol)) {
			qDebug() << "New PhysVol, storing it...";
			const GeoPhysVol* physVol = dynamic_cast<const GeoPhysVol*>(vol);
			// store the PhysVol volume into the DB
			physId = storeObj(physVol, logvolId, parentId, storeRootVolume); // with parent info
			qDebug() << "PhysVol stored. Id:" << physId.toString();
		}
		else if (dynamic_cast<const GeoFullPhysVol*>(vol)) {
			qDebug() << "New FullPhysVol, storing it...";
			const GeoFullPhysVol* fullVol = dynamic_cast<const GeoFullPhysVol*>(vol);
			// store the FullPhysVol volume into the DB
			physId = storeObj(fullVol, logvolId, parentId, storeRootVolume); // with parent info
			qDebug() << "FullPhysVol stored. Id:" << physId.toString();
		} else {
			qWarning() << "WARNING!! Unknown GeoVPhysVol type!!";
		}

	} else {
		//	qDebug() << "Volume stored already. It is a shared volume. Taking ID from memory map and moving to its physical children...";
		qDebug() << "Volume stored already. It is a shared volume. Taking ID from memory map...";
		physId = getStoredIdFromAddress(address);
		qDebug() << "PhysVol Id:" << physId;
	}


	// store the parent-child relationship in the DB

	QString parentType;
	if (parentNode) parentType = getGeoTypeFromVPhysVol(parentNode);
	else parentType = "NULL";
	QString childType  = getGeoTypeFromVPhysVol(vol);
	storeChildPosition(parentId, parentType, physId, getChildPosition( parentId.toUInt() ), childType);

}


QString DumpGeoModelAction::getGeoTypeFromVPhysVol(const GeoVPhysVol* vol)
{
	QString geoType;
	if (dynamic_cast<const GeoPhysVol*>(vol)) {
		qDebug() << "GeoType: GeoPhysVol";
		geoType = "GeoPhysVol";
	}
	else if (dynamic_cast<const GeoFullPhysVol*>(vol)) {
		qDebug() << "GeoType: GeoFullPhysVol";
		geoType = "GeoFullPhysVol";
	} else {
		qWarning() << "WARNING!! Unknown GeoVPhysVol type!!";
	}
	return geoType;
}


void DumpGeoModelAction::handleSerialDenominator (const GeoSerialDenominator *node)
{
	qDebug() << "\nDumpGeoModelAction::handleSerialDenominator(GeoSerialDenominator*)";

	QString address = getAddressStringFromPointer( node );


	std::string baseNameStr = node->getBaseName();
	QString baseName = QString::fromStdString(baseNameStr);
	qDebug() << "base name:" << baseName << "address:" << address;

	// TODO: check if needed!
	// check the volume position in the geometry tree
	GeoNodePath* path = getPath();
	unsigned int len = path->getLength();
	qDebug() << "length: " << len;

	// reset the number of visited node, if len is different than before
	if (len != m_len) {
		m_len_nChild = 0;
		m_len = len;
	}
	// update number of visited nodes if len is the same as before
	else {
		++m_len_nChild;
	}

	// variables used to persistify the object
	QVariant parentId;
	QVariant sdId;

	// get the parent volume, if this is not the Root volume
	const GeoVPhysVol* parentNode = nullptr;
	if (len > 1) { // TODO: check if needed!
		parentNode = path->getItem(len-1); // i=(len-1) gives you the parent VPhysVol
		QString parentAddress = getAddressStringFromPointer(parentNode);
		qDebug() << "parent's address:" << parentNode;

		if (isAddressStored(parentAddress))
			parentId = getStoredIdFromAddress(parentAddress);
		else
			qFatal("FATAL ERROR!!! - The parent node of this child should has been stored in the DB already, but it was not found!!");

		qDebug() << "- parent's LogVol name:" << QString::fromStdString(parentNode->getLogVol()->getName());
	} else{ // TODO: check if needed!
		qWarning() << "ERROR!! Len == 1, but this cannot be the Root volume!";
	}


	// check if this object has been stored already
	if (! isAddressStored(address)) {

		qDebug() << "New SerialDenominator, storing it...";


		/*
		 * STORE THE OBJECT IN THE DB
		 */

		// store the Material object in the DB
		sdId = storeObj(node, baseName);
		qDebug() << "SerialDenominator stored. Id:" << sdId.toString();

	} else {
		sdId = getStoredIdFromAddress(address);
		qDebug() << "SerialDenominator already stored in the DB. Id:" << sdId.toString();
	}

	QString parentType;
	if (parentNode) parentType = getGeoTypeFromVPhysVol(parentNode);
	else parentType = "NULL";
	storeChildPosition(parentId, parentType, sdId, getChildPosition( parentId.toUInt() ), "GeoSerialDenominator");

}



void DumpGeoModelAction::handleSerialTransformer (const GeoSerialTransformer *node)
{
	qDebug() << "\nDumpGeoModelAction::handleSerialTransformer(GeoSerialTransformer*)";

	QString address = getAddressStringFromPointer( node );

	// check the volume position in the geometry tree
	GeoNodePath* path = getPath();
	unsigned int len = path->getLength();
	qDebug() << "path length: " << len;

	// reset the number of visited node, if len is different than before
	if (len > m_len) {
		m_len_nChild = 0;
		m_len = len;
	}
	// update number of visited nodes if len is the same as before
	else {
		++m_len_nChild;
	}


	// variables used to persistify the object
	QVariant parentId;
	QVariant functionId;
	QVariant physvolId;
	QVariant physvolTable;
	unsigned int nCopies;
	QVariant stId;


	// get the parent volume, if this is not the Root volume
	const GeoVPhysVol* parentNode = nullptr;
	if (len > 1) {
		parentNode = path->getItem(len-1); // i=(len-1) gives you the parent VPhysVol
		QString parentAddress = getAddressStringFromPointer(parentNode);
		qDebug() << "parent's address:" << parentNode;

		if (isAddressStored(parentAddress))
			parentId = getStoredIdFromAddress(parentAddress);
		else
			qFatal("FATAL ERROR!!! - The parent node of this child should has been stored in the DB already, but it was not found!!");

		qDebug() << "- parent's LogVol name:" << QString::fromStdString(parentNode->getLogVol()->getName());
	} else{
		qWarning() << "ERROR!! Len == 1, but this cannot be the Root volume!";
	}


	// check if this object has been stored already
	if (! isAddressStored(address)) {

		qDebug() << "New SerialTransformer, storing it...";

		/*
		 * Get Node characteristics
		 *
		 * SerialTransformer features:
		 * - 1 parent PhysVol (if any)
		 * - 1 GENFUNCTION
		 * - 1 PhysVolId
		 * - 1 PhysVolType
		 * - 1 number of copies
		 */
		// get linked function and number of copies
		const GeoXF::Function * func = node->getFunction();
		nCopies =  node->getNCopies();
		qDebug() << "n. of copies:" << QString::number(nCopies);

		// get linked VPhysVol volume
		const GeoVPhysVol *vol = &( *( node->getVolume() ) );
		// const GeoPhysVol* vol = dynamic_cast<const GeoPhysVol*>(volV);
		QString volType;
		if (dynamic_cast<const GeoPhysVol*>(vol))
			volType = "GeoPhysVol";
		else if (dynamic_cast<const GeoFullPhysVol*>(vol))
			volType = "GeoFullPhysVol";
		else
			qWarning() << "ERROR!!! Unknown VPhysVol type!!";

		/*
		 * Persistify the Function
		 */
	 	TransFunctionPersistifier persistifier;
        try {
            persistifier.persistify(*func);
        } catch (const std::runtime_error & error) {
            std::cout << "Handling TransFunctionPersistifier std::runtime_error! -->" << error.what() << std::endl;
            std::cout << "SEVERE WARNING!! Handling std::runtime_error! -->" << error.what() << std::endl;
        }
		QString expression = QString::fromStdString( persistifier.getCodedString() );
		qDebug() << "FUNCTION:" << expression;

		if (expression.size() == 0) {
				qFatal("FATAL ERROR!! Function expression is empty!! Aborting...");
				abort();
		}


		/*
		 * STORE/GET THE INNER OBJECTS IN THE DB
		 */

		// store/get the Function object in the DB
		functionId = storeObj(func, expression);

		// store/get the PhysVol volume in the DB

		/* Concerning the physVol referenced by the SerialTransformer:
		 *
		 * - if physvol is not stored in the DB already;
		 * - if physVol has no parent (==NULL)
		 * ==> it means that its children will never visited by the NodeAction executed on the root tree
		 *
		 * ==> So, we need to persitify it as a new tree, to get all its children visited and persistified
		 *
		 */
		handleReferencedPhysVol(vol);

		QString physvolAddress = getAddressStringFromPointer(vol);
		physvolId = getStoredIdFromAddress(physvolAddress);


		/*
		 * STORE THE NODE INTO THE DB
		 */
		// store the SerialTransformer volume in the DB
		stId = storeObj(node, functionId, physvolId, volType, nCopies);
		qDebug() << "SerialTransformer stored. Id:" << stId.toString();

	} else {
		stId = getStoredIdFromAddress(address);
		qDebug() << "SerialTransformer already stored in the DB. Id:" << stId.toString();
	}

	QString parentType;
	if (parentNode) parentType = getGeoTypeFromVPhysVol(parentNode);
	else parentType = "NULL";
	storeChildPosition(parentId, parentType, stId, getChildPosition( parentId.toUInt() ), "GeoSerialTransformer");

}




void DumpGeoModelAction::handleTransform(const GeoTransform* node)
{
	qDebug() << "\nDumpGeoModelAction::handleTransform(GeoTransform*)";

	QString address = getAddressStringFromPointer( node );

	// check the volume position in the geometry tree
	GeoNodePath* path = getPath();
	unsigned int len = path->getLength();
	qDebug() << "length: " << len;

	// reset the number of visited node, if len is different than before
	if (len > m_len) {
		m_len_nChild = 0;
		m_len = len;
	}
	// update number of visited nodes if len is the same as before
	else {
		++m_len_nChild;
	}


	QVariant trId;
	QVariant parentId;


	// get the parent volume, if this is not the Root volume
	const GeoVPhysVol* parentNode = nullptr;
	if (len > 1) {
		parentNode = path->getItem(len-1); // i=(len-1) gives you the parent VPhysVol
		QString parentAddress = getAddressStringFromPointer(parentNode);
		qDebug() << "parent's address:" << parentNode;

		if (isAddressStored(parentAddress))
			parentId = getStoredIdFromAddress(parentAddress);
		else {
			// qFatal("FATAL ERROR!!! - The parent node of this child should has been stored in the DB already, but it was not found!!");
			qWarning() << "The parent node of this transform seems to not having be stored in the DB yet. [It is normal if the transformation is used for example only in the definition of a 'GeoShapeShift' instance]";
		}
		qDebug() << "- parent's LogVol name:" << QString::fromStdString(parentNode->getLogVol()->getName());
	} else{
		qWarning() << "ERROR!! Len == 1, but this cannot be the Root volume!";
	}

	/*
	 * STORE THE OBJECT IN THE DB AND ITS PLACE WITHIN THE TREE
	 */

	 // store the transformation in the DB
	 trId = storeTranform(node);


	// Store the child-parent relationship
	QString parentType;
	if (parentNode) parentType = getGeoTypeFromVPhysVol(parentNode);
	else parentType = "NULL";
	if ( dynamic_cast<const GeoAlignableTransform*>(node) ) {
		qDebug() << "Storing a GeoAlignableTransform...";
		storeChildPosition(parentId, parentType, trId, getChildPosition( parentId.toUInt() ), "GeoAlignableTransform");
	}
	else if ( dynamic_cast<const GeoTransform*>(node) ) {
		qDebug() << "Storing a GeoTransform...";
		storeChildPosition(parentId, parentType, trId, getChildPosition( parentId.toUInt() ), "GeoTransform");
	}
	else {
		qWarning("Not implemented yet!!!! ");
	}

}


void DumpGeoModelAction::handleNameTag(const GeoNameTag* node)
{
	qDebug() << "\nDumpGeoModelAction::handleNameTag(GeoNameTag*)";

	std::string nameStr = node->getName();
	QString name = QString::fromStdString(nameStr);
	qDebug() << "name:" << name;

	QString address = getAddressStringFromPointer( node );

	// check the volume position in the geometry tree
	GeoNodePath* path = getPath();
	unsigned int len = path->getLength();
	qDebug() << "length: " << len;

	// reset the number of visited node, if len is different than before
	if (len > m_len) {
		m_len_nChild = 0;
		m_len = len;
	}
	// update number of visited nodes if len is the same as before
	else {
		++m_len_nChild;
	}


	QVariant nameId;
	QVariant parentId;

	// get the parent volume, if this is not the Root volume
	const GeoVPhysVol* parentNode = nullptr;
	if (len > 1) {
		parentNode = path->getItem(len-1); // i=(len-1) gives you the parent VPhysVol
		QString parentAddress = getAddressStringFromPointer(parentNode);
		qDebug() << "parent's address:" << parentNode;

		if (isAddressStored(parentAddress))
			parentId = getStoredIdFromAddress(parentAddress);
		else {
			// qFatal("FATAL ERROR!!! - The parent node of this child should has been stored in the DB already, but it was not found!!");
			qWarning() << "The parent node of this transform seems to not having be stored in the DB yet. [It is normal if the transformation is used for example only in the definition of a 'GeoShapeShift' instance]";
		}
		qDebug() << "- parent's LogVol name:" << QString::fromStdString(parentNode->getLogVol()->getName());
	} else{
		qWarning() << "ERROR!! Len == 1, but this cannot be the Root volume!";
	}

	/*
	 * STORE THE OBJECT IN THE DB AND ITS PLACE WITHIN THE TREE
	 */

	 // store the name tag in the DB
	 nameId = storeObj(node, name);

	// Store the child-parent relationship
	QString parentType;
	if (parentNode) parentType = getGeoTypeFromVPhysVol(parentNode);
	else parentType = "NULL";
	storeChildPosition(parentId, parentType, nameId, getChildPosition( parentId.toUInt() ), "GeoNameTag");

}

QVariant DumpGeoModelAction::storeShape(const GeoShape* shape){
	const QString shapeType = QString::fromStdString(shape->type());
	qDebug() << "shape name:" << shapeType  << ", address:" << shape;
	// get shape parameters
	QString shapePars = getShapeParameters(shape);
	// store the shape in the DB and returns the ID
	return storeObj(shape, shapeType, shapePars);
}

QVariant DumpGeoModelAction::storeTranform(const GeoTransform* node){
	/*
	 * STORE THE OBJECT IN THE DB
	 */

	 QString address = getAddressStringFromPointer( node );

	 QVariant trId;

	// check if this object has been stored already
	if (! isAddressStored(address)) {

		qDebug() << "New Transform, storing it...";


		HepGeom::Transform3D tr = node->getTransform();

		std::vector<double> params = getTransformParameters(tr);
		qDebug() << "Transform parameters:" << QVector<double>::fromStdVector(params);

		/*
		 * STORE THE OBJECT IN THE DB
		 */

		// store the object in the DB
		if ( dynamic_cast<const GeoAlignableTransform*>(node) ) {
			trId = storeObj(dynamic_cast<const GeoAlignableTransform*>(node), params);
			qDebug() << "AlignableTransform stored. Id:" << trId.toString();
		}
		else if ( dynamic_cast<const GeoTransform*>(node) ) {
			trId = storeObj(dynamic_cast<const GeoTransform*>(node), params);
			qDebug() << "Transform stored. Id:" << trId.toString();
		}
		else {
			qDebug() << "WARNING!!! - This type of transformation needs to be customized yet!!";
		}

	} else {
		trId = getStoredIdFromAddress(address);
		qDebug() << "Transform already stored in the DB. Id:" << trId.toString();
	}

	return trId;
}


void DumpGeoModelAction::handleReferencedPhysVol (const GeoVPhysVol *vol)
{
	qDebug() << "\nDumpGeoModelAction::handleReferencedPhysVol(GeoVPhysVol*)";

	// qDebug() << "PhysVol's LogVol name:" << QString::fromStdString(vol->getLogVol()->getName());

	// get the address string for the current volume
	QString address = getAddressStringFromPointer( vol );

	QVariant parentId;
	bool unconnectedTree = false;

	// get the parent volume, if this is not the Root volume
	const GeoVPhysVol* parentNode = dynamic_cast<const GeoVPhysVol*>( &(*(vol->getParent() )));

	if (parentNode) {
		QString parentAddress = getAddressStringFromPointer(parentNode);
		qDebug() << "parent's address:" << parentNode;

		if (isAddressStored(parentAddress))
			parentId = getStoredIdFromAddress(parentAddress);
		//		else
		//			qFatal("FATAL ERROR!!! - The parent node of this child should has been stored in the DB already, but it was not found!!");

		qDebug() << "parent's LogVol name:" << QString::fromStdString(parentNode->getLogVol()->getName());
	}
	else {
		qDebug() << "NULL parent node!!";
		unconnectedTree = true;
	}

	// // counting children
	// unsigned int nChildren = vol->getNChildVols();
	// qDebug() << "number of child physical volumes:" << nChildren;
	// qDebug() << "[number of PhysVol and SerialTransformer child nodes:" << vol->getNChildVolAndST() << "]";
	//
	// GeoCountVolAction cv;
	// cv.setDepthLimit(1);
	// vol->exec(&cv);
	// int nChildCount = cv.getCount();
	// qDebug() << "number of child volumes:" << nChildCount;


	// check if this object has been stored already
	if (! isAddressStored(address)) {

		qDebug() << "This is a new root PhysVol node of an 'unconnected' tree, so we start another action on it to dump it into the DB...";

		// Dump tree volumes into a DB
			vol->exec(this); // TODO: check if the new action overwrites the id of the volumes already in the DB...!!!
	}
}


// Get shape parameters
QString DumpGeoModelAction::getShapeParameters(const GeoShape* shape)
{
	const QString shapeType = QString::fromStdString(shape->type());
	qDebug() << "shapeType:" << shapeType;

	QString shapePars = "";

	if (shapeType == "Box") {
		qDebug() << "get GeoBox parameters";
		QStringList pars;
		const GeoBox* box = dynamic_cast<const GeoBox*>(shape);
		pars << "XHalfLength=" + QString::number(box->getXHalfLength()) ;
		pars << "YHalfLength=" + QString::number(box->getYHalfLength()) ;
		pars << "ZHalfLength=" + QString::number(box->getZHalfLength()) ;
		shapePars = pars.join(";");
	} else if (shapeType == "Tube") {
		QStringList pars;
		const GeoTube* tube = dynamic_cast<const GeoTube*>(shape);
		pars << "RMin=" + QString::number(tube->getRMin()) ;
		pars << "RMax=" + QString::number(tube->getRMax()) ;
		pars << "ZHalfLength=" + QString::number(tube->getZHalfLength()) ;
		shapePars = pars.join(";");
	} else if (shapeType == "Cons") {
		QStringList pars;
		const GeoCons* shapeIn = dynamic_cast<const GeoCons*>(shape);
		pars << "RMin1=" + QString::number(shapeIn->getRMin1()) ;
		pars << "RMin2=" + QString::number(shapeIn->getRMin2()) ;
		pars << "RMax1=" + QString::number(shapeIn->getRMax1()) ;
		pars << "RMax2=" + QString::number(shapeIn->getRMax2()) ;
		pars << "DZ=" + QString::number(shapeIn->getDZ()) ;
		pars << "SPhi=" + QString::number(shapeIn->getSPhi()) ;
		pars << "DPhi=" + QString::number(shapeIn->getDPhi()) ;
		shapePars = pars.join(";");
	} else if (shapeType == "Para") {
		QStringList pars;
		const GeoPara* shapeIn = dynamic_cast<const GeoPara*>(shape);
		pars << "XHalfLength=" + QString::number(shapeIn->getXHalfLength()) ;
		pars << "YHalfLength=" + QString::number(shapeIn->getYHalfLength()) ;
		pars << "ZHalfLength=" + QString::number(shapeIn->getZHalfLength()) ;
		pars << "Alpha=" + QString::number(shapeIn->getAlpha()) ;
		pars << "Theta=" + QString::number(shapeIn->getTheta()) ;
		pars << "Phi=" + QString::number(shapeIn->getPhi()) ;
		shapePars = pars.join(";");
	} else if (shapeType == "Pcon") {
		QStringList pars;
		const GeoPcon* shapeIn = dynamic_cast<const GeoPcon*>(shape);
		pars << "SPhi=" + QString::number(shapeIn->getSPhi()) ;
		pars << "DPhi=" + QString::number(shapeIn->getDPhi()) ;
		shapePars = pars.join(";");
	} else if (shapeType == "Pgon") {
		QStringList pars;
		const GeoPgon* shapeIn = dynamic_cast<const GeoPgon*>(shape);
		pars << "SPhi=" + QString::number(shapeIn->getSPhi()) ;
		pars << "DPhi=" + QString::number(shapeIn->getDPhi()) ;
		pars << "NSides=" + QString::number(shapeIn->getNSides()) ;
		shapePars = pars.join(";");
	} else if (shapeType == "SimplePolygonBrep") {
		QStringList pars;
		const GeoSimplePolygonBrep* shapeIn = dynamic_cast<const GeoSimplePolygonBrep*>(shape);
		pars << "DZ=" + QString::number(shapeIn->getDZ()) ;
		shapePars = pars.join(";");
	} else if (shapeType == "Trap") {
		QStringList pars;
		const GeoTrap* shapeIn = dynamic_cast<const GeoTrap*>(shape);
		pars << "ZHalfLength=" + QString::number(shapeIn->getZHalfLength()) ;
		pars << "Theta=" + QString::number(shapeIn->getTheta()) ;
		pars << "Phi=" + QString::number(shapeIn->getPhi()) ;
		pars << "Dydzn=" + QString::number(shapeIn->getDydzn()) ;
		pars << "Dxdyndzn=" + QString::number(shapeIn->getDxdyndzn()) ;
		pars << "Dxdypdzn=" + QString::number(shapeIn->getDxdypdzn()) ;
		pars << "Angleydzn=" + QString::number(shapeIn->getAngleydzn()) ;
		pars << "Dydzp=" + QString::number(shapeIn->getDydzp()) ;
		pars << "Dxdyndzp=" + QString::number(shapeIn->getDxdyndzp()) ;
		pars << "Dxdypdzp=" + QString::number(shapeIn->getDxdypdzp()) ;
		pars << "Angleydzp=" + QString::number(shapeIn->getAngleydzp()) ;
		shapePars = pars.join(";");
	} else if (shapeType == "Trd") {
		QStringList pars;
		const GeoTrd* shapeIn = dynamic_cast<const GeoTrd*>(shape);
		pars << "XHalfLength1=" + QString::number(shapeIn->getXHalfLength1()) ;
		pars << "XHalfLength2=" + QString::number(shapeIn->getXHalfLength2()) ;
		pars << "YHalfLength1=" + QString::number(shapeIn->getYHalfLength1()) ;
		pars << "YHalfLength2=" + QString::number(shapeIn->getYHalfLength2()) ;
		pars << "ZHalfLength=" + QString::number(shapeIn->getZHalfLength()) ;
		shapePars = pars.join(";");
	} else if (shapeType == "Tubs") {
		QStringList pars;
		const GeoTubs* shapeIn = dynamic_cast<const GeoTubs*>(shape);
		pars << "RMin=" + QString::number(shapeIn->getRMin()) ;
		pars << "RMax=" + QString::number(shapeIn->getRMax()) ;
		pars << "ZHalfLength=" + QString::number(shapeIn->getZHalfLength()) ;
		pars << "SPhi=" + QString::number(shapeIn->getSPhi()) ;
		pars << "DPhi=" + QString::number(shapeIn->getDPhi()) ;
		shapePars = pars.join(";");
	}
	else if (shapeType == "Shift") {
		qDebug() << "get GeoShapeShift parameters";
		QStringList pars;
		const GeoShapeShift* shapeIn = dynamic_cast<const GeoShapeShift*>(shape);

		// get the pointed Shape, store it in the DB
		const GeoShape* shapeOp = shapeIn->getOp();
		QVariant shapeId = storeShape(shapeOp);

		// get the Transformation, store it in the DB
		const HepGeom::Transform3D transfX = shapeIn->getX();
		GeoTransform* transf = new GeoTransform(transfX);
		QVariant trId = storeTranform(transf);

		pars << "A=" + QString::number( shapeId.toUInt() ) ;
		pars << "X=" + QString::number( trId.toUInt() ) ;
		shapePars = pars.join(";");
	}
	else {
		qDebug() << "WARNING!!! - Shape '" << shapeType << "' needs to be customized!!";
	}

  return shapePars;

}


std::vector<double> DumpGeoModelAction::getTransformParameters(HepGeom::Transform3D tr)
{
	std::vector<double> vec;

	vec.push_back(tr.xx());
	vec.push_back(tr.xy());
	vec.push_back(tr.xz());

	vec.push_back(tr.yx());
	vec.push_back(tr.yy());
	vec.push_back(tr.yz());

	vec.push_back(tr.zx());
	vec.push_back(tr.zy());
	vec.push_back(tr.zz());

	vec.push_back(tr.dx());
	vec.push_back(tr.dy());
	vec.push_back(tr.dz());

	return vec;
}


DumpGeoModelAction::DumpGeoModelAction(GMDBManager &db)
{
	qDebug() << "DumpGeoModelAction: constructor";

	// init variables
	m_len = 0;
	m_len_nChild = 0;
	m_rootVolumeFound = false;

	// init anche check the database handle
	m_dbManager = &db;
	if (m_dbManager->isOpen()) {
		qDebug() << "OK! Database is open!";
	}
	else {
		qDebug() << "Database is not open!";
	}

	// QString pippo = "pippo";

}

DumpGeoModelAction::~DumpGeoModelAction()
{
	// nothing to do so far...
}


void DumpGeoModelAction::showMemoryMap()
{
	qDebug() << "DumpGeoModelAction::showMemoryMap()";

	QMap<QString, QVariant>::const_iterator it = m_memMap.constBegin();
	while (it != m_memMap.constEnd()) {
		std::cout << it.key().toStdString() << ": " << it.value().toString().toStdString() << std::endl;
		++it;
	}
}



QVariant DumpGeoModelAction::storeObj(const GeoMaterial* pointer, const QString name)
{
	qDebug() << "DumpGeoModelAction::storeObj(GeoMaterial*) - name:" << name << "address:" << pointer;

	QString address = getAddressStringFromPointer( pointer );
	QVariant materialId;

	if (! isAddressStored(address)) {
		qDebug() << "New Material! Storing it...";

		materialId = m_dbManager->addMaterial(name);
		materialId = m_dbManager->addMaterial(name);

		storeAddress( address, materialId );
	}
	else {
		qDebug() << "Material node stored already. Getting ID from the memory map...";
		materialId = getStoredIdFromAddress(address);
	}
	qDebug() << "materialId:" << materialId;
	return materialId;
}

QVariant DumpGeoModelAction::storeObj(const GeoShape* pointer, const QString name, const QString parameters)
{
	qDebug() << "DumpGeoModelAction::storeObj(GeoShape*) - name:" << name << "address:" << pointer;

	QString address = getAddressStringFromPointer( pointer );

	QVariant shapeId;
	if (! isAddressStored(address)) {
		qDebug() << "New Shape! Storing it...";
		shapeId = m_dbManager->addShape(name, parameters);
		storeAddress( address, shapeId);
	}
	else {
		qDebug() << "Shape node stored already. Getting ID from the memory map...";
		shapeId = getStoredIdFromAddress(address);
	}
	qDebug() << "shapeId:" << shapeId;
	return shapeId;
}

QVariant DumpGeoModelAction::storeObj(const GeoLogVol* pointer, const QString name, const QVariant shapeId, const QVariant materialId)
{
	qDebug() << "DumpGeoModelAction::storeObj(GeoLogVol*) - name:" << name << "address:" << pointer;

	QString address = getAddressStringFromPointer( pointer );

	QVariant logvolId;
	if (! isAddressStored(address)) {
		qDebug() << "New LogVol! Storing it...";
		logvolId = m_dbManager->addLogVol(name, shapeId, materialId);
		storeAddress( address, logvolId );
	}
	else {
		qDebug() << "LogVol node stored already. Getting ID from the memory map...";
		logvolId = getStoredIdFromAddress(address);
	}
	qDebug() << "logvolId:" << logvolId;
	return logvolId;
}


QVariant DumpGeoModelAction::storeObj(const GeoPhysVol* pointer, const QVariant logvolId, const QVariant parentId, bool isRootVolume)
{
	qDebug() << "DumpGeoModelAction::storeObj(GeoPhysVol*) - address:" << pointer << "- is root volume?" << isRootVolume;

	QString address = getAddressStringFromPointer( pointer );

	QVariant physvolId;
	if (! isAddressStored(address)) {
		qDebug() << "New PhysVol! Storing it...";
		physvolId = m_dbManager->addPhysVol(logvolId, parentId, isRootVolume);
		storeAddress( address, physvolId );
	}
	else {
		qDebug() << "PhysVol node stored already. Getting ID from the memory map...";
		physvolId = getStoredIdFromAddress(address);
	}
	qDebug() << "physvolId:" << physvolId;
	return physvolId;
}

QVariant DumpGeoModelAction::storeObj(const GeoFullPhysVol* pointer, const QVariant logvolId, const QVariant parentId, bool isRootVolume)
{
	qDebug() << "DumpGeoModelAction::storeObj(GeoFullPhysVol*) - address:" << pointer << "- is root volume?" << isRootVolume;

	QString address = getAddressStringFromPointer( pointer );

	QVariant physvolId;
	if (! isAddressStored(address)) {
		qDebug() << "New FullPhysVol! Storing it...";
		physvolId = m_dbManager->addFullPhysVol(logvolId, parentId, isRootVolume);
		storeAddress( address, physvolId );
	}
	else {
		qDebug() << "FullPhysVol node stored already. Getting ID from the memory map...";
		physvolId = getStoredIdFromAddress(address);
	}
	qDebug() << "fullphysvolId:" << physvolId;
	return physvolId;
}

QVariant DumpGeoModelAction::storeObj(const GeoSerialDenominator* pointer, const QString baseName)
{
	qDebug() << "DumpGeoModelAction::storeObj(GeoSerialDenominator*) - baseName:" << baseName << "address:" << pointer;

	QString address = getAddressStringFromPointer( pointer );
	QVariant id;

	if (! isAddressStored(address)) {
		qDebug() << "New SerialDenominator! Storing it...";
		id = m_dbManager->addSerialDenominator(baseName);
		storeAddress( address, id );
	}
	else {
		qDebug() << "SerialDenominator node stored already. Getting ID from the memory map...";
		id = getStoredIdFromAddress(address);
	}
	qDebug() << "ID:" << id;
	return id;
}


QVariant DumpGeoModelAction::storeObj(const GeoSerialTransformer* pointer, const QVariant functionId, const QVariant volId, const QString volType, const unsigned int copies)
{
	qDebug() << "DumpGeoModelAction::storeObj(GeoSerialTransformer*):" << volId << volType << "- n. of copies: " << copies;

	QString address = getAddressStringFromPointer( pointer );
	QVariant id;

	if (! isAddressStored(address)) {
		qDebug() << "New SerialTransformer! Storing it...";
		id = m_dbManager->addSerialTransformer(functionId, volId, volType, copies);
		storeAddress( address, id );
	}
	else {
		qDebug() << "SerialTransformer node stored already. Getting ID from the memory map...";
		id = getStoredIdFromAddress(address);
	}
	qDebug() << "ID:" << id;
	return id;
}

QVariant DumpGeoModelAction::storeObj(const GeoXF::Function* pointer, const QString expression)
{
	qDebug() << "DumpGeoModelAction::storeObj(GeoXF::Function*)";

	QString address = getAddressStringFromPointer( pointer );
	QVariant id;

	if (! isAddressStored(address)) {
		qDebug() << "New GeoXF::Function! Storing it...";
		id = m_dbManager->addFunction(expression);
		storeAddress( address, id );
	}
	else {
		qDebug() << "GeoXF::Function node stored already. Getting ID from the memory map...";
		id = getStoredIdFromAddress(address);
	}
	qDebug() << "ID:" << id;
	return id;
}

QVariant DumpGeoModelAction::storeObj(const GeoTransform* pointer, std::vector<double> parameters)
{
	qDebug() << "DumpGeoModelAction::storeObj(GeoTransform*)";


	QString address = getAddressStringFromPointer( pointer );
	QVariant id;

	if (! isAddressStored(address)) {
		qDebug() << "New GeoXF::Function! Storing it...";

		id = m_dbManager->addTransform( QVector<double>::fromStdVector(parameters) );
		storeAddress( address, id );
	}
	else {
		qDebug() << "GeoTransform node stored already. Getting ID from the memory map...";
		id = getStoredIdFromAddress(address);
	}
	qDebug() << "ID:" << id;
	return id;
}

QVariant DumpGeoModelAction::storeObj(const GeoAlignableTransform* pointer, std::vector<double> parameters)
{
	qDebug() << "DumpGeoModelAction::storeObj(GeoAlignableTransform*)";


	QString address = getAddressStringFromPointer( pointer );
	QVariant id;

	if (! isAddressStored(address)) {
		qDebug() << "New GeoXF::Function! Storing it...";

		id = m_dbManager->addAlignableTransform( QVector<double>::fromStdVector(parameters) );
		storeAddress( address, id );
	}
	else {
		qDebug() << "GeoAlignableTransform node stored already. Getting ID from the memory map...";
		id = getStoredIdFromAddress(address);
	}
	qDebug() << "ID:" << id;
	return id;
}


QVariant DumpGeoModelAction::storeObj(const GeoNameTag* pointer, const QString name)
{
	qDebug() << "DumpGeoModelAction::storeObj(GeoNameTag*) - name:" << name << "address:" << pointer;

	QString address = getAddressStringFromPointer( pointer );
	QVariant id;

	if (! isAddressStored(address)) {
		qDebug() << "New SerialDenominator! Storing it...";
		id = m_dbManager->addNameTag(name);
		storeAddress( address, id );
	}
	else {
		qDebug() << "SerialDenominator node stored already. Getting ID from the memory map...";
		id = getStoredIdFromAddress(address);
	}
	qDebug() << "ID:" << id;
	return id;
}


void DumpGeoModelAction::storeChildPosition(const QVariant parentId, const QString parentType, const QVariant childId, const unsigned int childPos, const QString childType)
{
	qDebug() << "DumpGeoModelAction::storeChildPosition()";

	m_dbManager->addChildPosition(parentId, parentType, childId, childPos, childType);
	return;

}


void DumpGeoModelAction::storeAddress(const QString address, QVariant id)
{
	qDebug() << "DumpGeoModelAction::storeAddress(" << address << "," << id << ")";
	m_memMap.insert(address, id);
}

bool DumpGeoModelAction::isAddressStored(const QString address)
{
	qDebug() << "DumpGeoModelAction::isAddressStored(): " << address;
	//showMemoryMap(); // only for Debug
	return m_memMap.contains(address);
}


QVariant DumpGeoModelAction::getStoredIdFromAddress(QString address)
{
	qDebug() << "DumpGeoModelAction::getStoredIdFromAddress(): " << address;
	return m_memMap.value(address);
}

// get pointer string
QString DumpGeoModelAction::getAddressStringFromPointer(const GeoMaterial* pointer)
{
	qDebug() << "DumpGeoModelAction::getAddressStringFromPointer(GeoMaterial*)";
	std::ostringstream oss;
	oss << pointer;
	return getQStringFromOss(oss);
}
// get pointer string
QString DumpGeoModelAction::getAddressStringFromPointer(const GeoShape* pointer)
{
	qDebug() << "DumpGeoModelAction::getAddressStringFromPointer(GeoShape*)";
	std::ostringstream oss;
	oss << pointer;
	return getQStringFromOss(oss);
}
// get pointer string
QString DumpGeoModelAction::getAddressStringFromPointer(const GeoLogVol* pointer)
{
	qDebug() << "DumpGeoModelAction::getAddressStringFromPointer(GeoLogVol*)";
	std::ostringstream oss;
	oss << pointer;
	return getQStringFromOss(oss);
}
// get pointer string
QString DumpGeoModelAction::getAddressStringFromPointer(const GeoPhysVol* pointer)
{
	qDebug() << "DumpGeoModelAction::getAddressStringFromPointer(GeoPhysVol*)";
	std::ostringstream oss;
	oss << pointer;
	return getQStringFromOss(oss);
}
QString DumpGeoModelAction::getAddressStringFromPointer(const GeoVPhysVol* pointer)
{
	qDebug() << "DumpGeoModelAction::getAddressStringFromPointer(GeoVPhysVol*)";
	std::ostringstream oss;
	oss << pointer;
	return getQStringFromOss(oss);
}
// get pointer string
QString DumpGeoModelAction::getAddressStringFromPointer(const GeoSerialDenominator* pointer)
{
	qDebug() << "DumpGeoModelAction::getAddressStringFromPointer(GeoSerialDenominator*)";
	std::ostringstream oss;
	oss << pointer;
	return getQStringFromOss(oss);
}
QString DumpGeoModelAction::getAddressStringFromPointer(const GeoSerialTransformer* pointer)
{
	qDebug() << "DumpGeoModelAction::getAddressStringFromPointer(GeoSerialTransformer*)";
	std::ostringstream oss;
	oss << pointer;
	return getQStringFromOss(oss);
}
QString DumpGeoModelAction::getAddressStringFromPointer(const GeoXF::Function* pointer)
{
	qDebug() << "DumpGeoModelAction::getAddressStringFromPointer(GeoXF::Function*)";
	std::ostringstream oss;
	oss << pointer;
	return getQStringFromOss(oss);
}

QString DumpGeoModelAction::getAddressStringFromPointer(const GeoTransform* pointer)
{
	qDebug() << "DumpGeoModelAction::getAddressStringFromPointer(GeoTransform*)";
	std::ostringstream oss;
	oss << pointer;
	return getQStringFromOss(oss);
}

QString DumpGeoModelAction::getAddressStringFromPointer(const GeoNameTag* pointer)
{
	qDebug() << "DumpGeoModelAction::getAddressStringFromPointer(GeoNameTag*)";
	std::ostringstream oss;
	oss << pointer;
	return getQStringFromOss(oss);
}

QString DumpGeoModelAction::getQStringFromOss(std::ostringstream &oss)
{
	qDebug() << "DumpGeoModelAction::getQStringFromOss()";
	std::string addr = oss.str();
	QString address = QString::fromStdString(addr);
	qDebug() << "address string:" << address;
	return address;
}


//bool DumpGeoModelAction::isObjectStored(const GeoMaterial* pointer)
//{
//	qDebug() << "DumpGeoModelAction::isObjectStored(const GeoMaterial*)";
//	return isAddressStored(getAddressStringFromPointer( pointer) );
//}
//
//bool DumpGeoModelAction::isObjectStored(const GeoGraphNode* pointer)
//{
//	qDebug() << "DumpGeoModelAction::isObjectStored(const GeoGraphNode*)";
////	return isAddressStored(address);
//}



// void DumpGeoModelAction::handlePhysVol (const GeoPhysVol *vol)
// {
// 	qDebug() << "\nDumpGeoModelAction::handlePhysVol(GeoPhysVol*)";
//
// 	// get the address string for the current volume
// 	QString address = getAddressStringFromPointer( vol );
//
// 	// variables used to persistify the object
// 	QVariant parentId;
// 	QVariant physId;
//
// 	// check the volume position in the geometry tree
// 	GeoNodePath* path = getPath();
// 	unsigned int len = path->getLength();
// 	qDebug() << "length: " << len;
// 	//	std::cout << "path: " << path << std::endl;
//
// //	const GeoVPhysVol* parentNode;
//
// 	// this below is performed until the root volume is found, then "length" is not used anymore,
// 	// because not updated when recursively visiting PhysVols
// 	bool getParentNode = true;
// 	bool storeRootVolume = false;
// 	if ( ! m_rootVolumeFound) {
// 		if (len > 1) {
// 			getParentNode = true;
// 		} else{
// 			qDebug() << "This is the Root volume!";
// 			m_rootVolumeFound = true;
// 			storeRootVolume = true;
// 			getParentNode = false;
// 		}
// 	} else {
// 		getParentNode = true;
// 	}
//
// 	// get the parent volume, if this is not the Root volume
// 	if (getParentNode) {
//
// 		const GeoPhysVol* parentNode = dynamic_cast<const GeoPhysVol*>( &(*(vol->getParent() )));
//
// 		if (parentNode) {
// 			QString parentAddress = getAddressStringFromPointer(parentNode);
// 			qDebug() << "parent's address:" << parentNode;
//
// 			if (isAddressStored(parentAddress))
// 				parentId = getStoredIdFromAddress(parentAddress);
// 			//		else
// 			//			qFatal("FATAL ERROR!!! - The parent node of this child should has been stored in the DB already, but it was not found!!");
//
// 			qDebug() << "parent's LogVol name:" << QString::fromStdString(parentNode->getLogVol()->getName());
// 		}
// 		else {
// 			qDebug() << "NULL parent node!!";
// 		}
// 	}
//
// 	// counting children
// 	unsigned int nChildren = vol->getNChildVols();
// 	qDebug() << "number of child physical volumes:" << nChildren;
// 	qDebug() << "[number of PhysVol and SerialTransformer child nodes:" << vol->getNChildVolAndST() << "]";
//
// 	GeoCountVolAction cv;
// 	cv.setDepthLimit(1);
// 	vol->exec(&cv);
// 	int nChildCount = cv.getCount();
// 	qDebug() << "number of child volumes:" << nChildCount;
//
//
//
// 	// check if this object has been stored already
// 	if (! isAddressStored(address)) {
//
// 		qDebug() << "New PhysVol, storing it...";
//
// 		/*
// 		 * PhysVol features:
// 		 * - 1 parent PhysVol (if any)
// 		 * - 1 LogVol
// 		 * - 1 Material
// 		 * - 1 Shape
// 		 */
//
// 		// Note: PhysVol has no name. Its LogVol has a name.
// 		//	  const std::string name = vol->getLogVol()->getName();
//
// 		// LOGVOL
// 		const GeoLogVol* logVol = vol->getLogVol();
// 		const QString logName = QString::fromStdString(logVol->getName());
// 		qDebug() << "LogVol name:"  << logName;
//
//
// 		// MATERIAL
// 		const GeoMaterial * mat = vol->getLogVol()->getMaterial();
// 		const QString matName = QString::fromStdString(mat->getName());
// 		qDebug() << "material name:" << matName << ", address:" << mat;
//
//
// 		// SHAPE
// 		const GeoShape * shape = vol->getLogVol()->getShape();
// 		const QString shapeType = QString::fromStdString(shape->type());
// 		qDebug() << "shape name:" << shapeType  << ", address:" << shape;
//
// 		// shape parameters
// 		QString shapePars = "";
// 		if (shapeType == "Box") {
// 			QStringList pars;
// 			const GeoBox* box = dynamic_cast<const GeoBox*>(shape);
// 			pars << "XHalfLength=" + QString::number(box->getXHalfLength()) ;
// 			pars << "YHalfLength=" + QString::number(box->getYHalfLength()) ;
// 			pars << "ZHalfLength=" + QString::number(box->getZHalfLength()) ;
// 			shapePars = pars.join(";");
// 		}
//
// 		/*
// 		 * STORE THE OBJECTS IN THE DB
// 		 */
//
// 		// store/get the Material object into/from the DB
// 		QVariant matId;
// 		matId = storeObj(mat, matName);
//
// 		// store/get the Shape object into/from the DB
// 		QVariant shapeId;
// 		shapeId = storeObj(shape, shapeType, shapePars);
//
// 		// store/get the LogVol object into/from the DB
// 		QVariant logvolId;
// 		logvolId = storeObj(logVol, logName, shapeId, matId);
//
// 		// store the PhysVol volume into the DB
// 		physId = storeObj(vol, logvolId, parentId, storeRootVolume); // with parent info
// 		qDebug() << "PhysVol stored. Id:" << physId.toString();
//
// 	} else {
// 		//	qDebug() << "Volume stored already. It is a shared volume. Taking ID from memory map and moving to its physical children...";
// 		qDebug() << "Volume stored already. It is a shared volume. Taking ID from memory map...";
// 		physId = getStoredIdFromAddress(address);
// 		qDebug() << "PhysVol Id:" << physId;
// 	}
//
//
// 	// store the parent-child relationship in the DB
// 	storeChildPosition(parentId, physId, getChildPosition( parentId.toUInt() ), "GeoPhysVol");
//

	/* Now we need to loop over children, to be sure all volumes are take.
	 That's because it seems that the action only goes to children that are 'attached'
	 to the tree with a parent-child relationship. For example I have a pInnerPassive PhysVol
	 added to a pPassive PhysVol; the latter is refeneced in a SerialTransformer.
	 pPassive is visited because of our implementation of the handleSerialTrasformer() method,
	 but the pInnerPassive is never visited.
	 */
	//	if (nChildren > 0) {
	//		qDebug() << "Looping over the children...";
	//
	//		for (unsigned int i=0; i<nChildren; ++i) {
	//
	//			unsigned int childPos = i;
	//
	//			// get the name of the i-th child volume
	//			QString childName =  QString::fromStdString(vol->getNameOfChildVol(i));
	//			qDebug() << "\t" << i << " childName:" << childName;
	//
	//			//	Returns the i-th child volume
	//
	//			// GEOPHYSVOL child
	//			if ( dynamic_cast<const GeoPhysVol*>( &(*(vol->getChildVol(i) ))) ) {
	//				qDebug() << "\t\t" << "the child" << i << "is a GeoPhysVol";
	//				const GeoVPhysVol *childVolV = &(*(vol->getChildVol(i)));
	//				const GeoPhysVol* childVol = dynamic_cast<const GeoPhysVol*>(childVolV);
	//
	//				handlePhysVol(childVol); // recursive call
	//
	//			} else {
	//				qCritical("\t\tERROR!! the child is not a persistified volume/node!!!");
	//				return;
	//			}
	//		}
	//	}

	//	if (nChildren > 0) {
	//		for (unsigned int i=0; i<nChildren; ++i) {
	//
	//			unsigned int childPos = i;
	//
	//			// get the name of the i-th child volume
	//			QString childName =  QString::fromStdString(vol->getNameOfChildVol(i));
	//			qDebug() << "\t" << i << " childName:" << childName;
	//
	//			//	Returns the i-th child volume
	//
	//			// GEOPHYSVOL child
	//			if ( dynamic_cast<const GeoPhysVol*>( &(*(vol->getChildVol(i) ))) ) {
	//				qDebug() << "\t\t" << "the child" << i << "is a GeoPhysVol";
	//				const GeoVPhysVol *childVolV = &(*(vol->getChildVol(i)));
	//				const GeoPhysVol* childVol = dynamic_cast<const GeoPhysVol*>(childVolV);
	//
	//
	//				// check if child volume has been stored already. If not, store it.
	//				if ( ! isAddressStored( getAddressStringFromPointer( childVol )) ) {
	//
	//					// MATERIAL
	//					const GeoMaterial * mat = childVol->getLogVol()->getMaterial();
	//					const QString matName = QString::fromStdString(mat->getName());
	//					qDebug() << "Child material name:" << matName;
	//
	//					// SHAPE
	//					const GeoShape * shape = childVol->getLogVol()->getShape();
	//					const QString shapeType = QString::fromStdString(shape->type());
	//					qDebug() << "Child shape name:" << shapeType;
	//
	//					// LOGVOL
	//					const GeoLogVol* logVol = childVol->getLogVol();
	//					const QString logName = QString::fromStdString(logVol->getName());
	//					qDebug() << "Child LogVol name:"  << logName;
	//
	//
	//					/*
	//					 * STORE THE OBJECTS IN THE DB
	//					 */
	//
	//					// store the Material object in the DB
	//					QVariant child_matId = storeObj(mat, matName);
	//
	//					// store the Shape object in the DB
	//					QVariant child_shapeId = storeObj(shape, shapeType);
	//
	//					// store the LogVol volume in the DB
	//					QVariant child_logvolId = storeObj(logVol, logName, child_shapeId, child_matId);
	//
	//					// store the PhysVol volume in the DB
	//					storeObj(childVol, child_logvolId, physId);
	//
	//					// store the parent-child relationship in the DB
	//					storeChildPosition(physId, childVol, childPos);
	//
	//				} else {
	//					qDebug() << "Child volume stored already. Moving to the next one...";
	//				}
	//
	//			}
	//			// GeoSerialDenominator child
	//			else if ( dynamic_cast<const GeoSerialDenominator*>( &(*(vol->getChildVol(i) ))) ) {
	//				qDebug() << "\t\t" << "the child" << i << "is a GeoSerialDenominator";
	//				//qWarning() << "\t\t" << "to be implemented!!!";
	//				const GeoVPhysVol *childVolV = &(*(vol->getChildVol(i)));
	//				const GeoSerialDenominator* childVol = dynamic_cast<const GeoSerialDenominator*>(childVolV);
	//
	//				std::string baseNameStr = childVol->getBaseName();
	//				QString baseName = QString::fromStdString(baseNameStr);
	//
	//				QString address = getAddressStringFromPointer( childVol );
	//
	//				qDebug() << "base name:" << baseName << "address:" << address;
	//
	//				QVariant sdId;
	//
	//				// check if this object has been stored already
	//				if (! isAddressStored(address)) {
	//					// store the SerialDenominator object in the DB
	//					qDebug() << "New SerialDenominator, storing it...";
	//					sdId = storeObj(childVol, baseName);
	//					qDebug() << "SerialDenominator stored. Id:" << sdId.toString();
	//
	//				} else {
	//					sdId = getStoredIdFromAddress(address);
	//					qDebug() << "SerialDenominator already stored in the DB. Got id:" << sdId.toString();
	//				}
	//
	//				// store the parent-child relationship in the DB
	//				storeChildPosition(physId, childVol, childPos);
	//
	//			}
	//			// GEOFULLPHYSVOL child
	//			else if ( dynamic_cast<const GeoFullPhysVol*>( &(*(vol->getChildVol(i) ))) ) {
	//				qDebug() << "\t\t" << "the child" << i << "is a GeoFullPhysVol";
	//				qWarning() << "\t\t" << "to be implemented!!!";
	//				//				const GeoVFullPhysVol *childVolV = &(*(vol->getChildVol(i)));
	//				//				const GeoFullPhysVol* childVol = dynamic_cast<const GeoFullPhysVol*>(childVolV);
	//			}
	//			else {
	//				qCritical("\t\tERROR!! the child is not a persistified volume/node!!!");
	//				return;
	//			}
	//
	//
	//			// examples:
	//			//const GeoVPhysVol *child=&(*(pv->getChildVol(i)));
	//			//
	//			//if ( dynamic_cast<const GeoLogVol*>( &(*(vol->getChildVol(i) ))) )
	//			//	qDebug() << "\t\t" << "the child" << i << "is a GeoLogVol";
	//
	//
	//
	//			/*
	//				unsigned int nchildvol = pvc->getNChildVols();
	//				     int lgg = 0;
	//				     int llay = 0;
	//				     std::string::size_type npos;
	//				     for (unsigned ich=0; ich<nchildvol; ++ich) {
	//				       PVConstLink pc = pvc->getChildVol(ich);
	//				       std::string childname = (pc->getLogVol())->getName();
	//				       if ((npos = childname.find("layer")) != std::string::npos ) {
	//				         llay ++;
	//				         //std::cerr<<" navigating RPC named "
	//				         //       <<tname<<" child "
	//				         //       <<ich<<" is a layer with tag "<<llay<<std::endl;
	//				         unsigned int nch1 = pc->getNChildVols();
	//				         lgg = 0;
	//				         for (unsigned ngv=0; ngv<nch1; ++ngv) {
	//				           PVConstLink pcgv = pc->getChildVol(ngv);
	//				           std::string childname1 = (pcgv->getLogVol())->getName();
	//				           if ((npos = childname1.find("gas volume")) != std::string::npos ) {
	//				         lgg ++;
	//				         //std::cerr<<" navigating RPC named "
	//				         //       <<tname<<" child "
	//				         //       <<ngv<<" is a gas volume  with tag "<<lgg<<std::endl;
	//				         PVConstLink pcgg = pcgv->getChildVol(0);
	//				         HepGeom::Transform3D trans = pvc->getXToChildVol(ich)*pc->getXToChildVol(ngv)*pcgv->getXToChildVol(0);
	//				         m_Xlg[llay-1][lgg-1] = Amg::CLHEPTransformToEigen(trans);
	//				           }
	//				         }
	//				       }
	//				     }
	//			 */
	//
	//		}
	//	}


	//	else {
	//		qDebug() << "Object stored already. Moving to next one...";
	//	}
// }
