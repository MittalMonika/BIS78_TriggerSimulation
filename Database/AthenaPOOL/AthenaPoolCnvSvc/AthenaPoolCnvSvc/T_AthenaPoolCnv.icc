/*
  Copyright (C) 2002-2017 CERN for the benefit of the ATLAS collaboration
*/

/** @file T_AthenaPoolCnv.icc
 *  @brief This file contains the implementation for the templated T_AthenaPoolCnv class.
 *  @author Peter van Gemmeren <gemmeren@anl.gov>
 **/

#include "AthenaPoolCnvSvc/IAthenaPoolCnvSvc.h"

#include "GaudiKernel/StatusCode.h"
#include "GaudiKernel/DataObject.h"
#include "GaudiKernel/IOpaqueAddress.h"
#include "GaudiKernel/IRegistry.h"
#include "PersistentDataModel/Token.h"

#include "DataModelRoot/RootType.h"

#include "CLIDSvc/CLASS_DEF.h"
#include "DataModel/ClassName.h"
#include "SGTools/StorableConversions.h"

//__________________________________________________________________________
template <class T>
T_AthenaPoolCnv<T>::T_AthenaPoolCnv(ISvcLocator* svcloc) : AthenaPoolConverter(classID(), svcloc) {
}
//______________________________________________________________________________
template <class T>
StatusCode T_AthenaPoolCnv<T>::initialize() {
   ATH_MSG_DEBUG("initialize() in T_AthenaPoolCnv " << classID());
   if (!AthenaPoolConverter::initialize().isSuccess()) {
      ATH_MSG_FATAL("Failed to initialize AthenaPoolConverter base class.");
      return(StatusCode::FAILURE);
   }
   return(StatusCode::SUCCESS);
}
//__________________________________________________________________________
template <class T>
const CLID& T_AthenaPoolCnv<T>::classID() {
   return(ClassID_traits<T>::ID());
}
//__________________________________________________________________________
template <class T>
StatusCode T_AthenaPoolCnv<T>::DataObjectToPool(DataObject* /*pObj*/, const std::string& key) {
   const std::string className = ClassName<T>::name();
   if (!m_dictionaryOkWrite) {
      m_dictionaryOkWrite = m_athenaPoolCnvSvc->testDictionary(className);
   }
   if (!m_dictionaryOkWrite) {
      ATH_MSG_ERROR("There is no correct dictionary for class (type/key) " << className << "/" << getDataObject()->name());
      return(StatusCode::FAILURE);
   }
   if (!m_classDesc) {
      ATH_MSG_DEBUG("Retrieve class description for class (type/key) " << className << "/" << getDataObject()->name());
      m_classDesc = RootType( typeid(T) );
   }
   if (this->getDataObject()->clID() == 1 && this->getDataObject()->registry()->address() != 0) {
      ATH_MSG_DEBUG("Failed to cast DataObject to transient type, doing pers to pers");
      if (this->m_poolToken == 0) this->m_poolToken = new Token;
      const_cast<Token*>(m_poolToken)->fromString(this->getDataObject()->registry()->address()->par()[0]); //FIXME: get TokenAddress?
      DataObject* pObj = 0;
      if (!PoolToDataObject(pObj, "").isSuccess()) {
         delete this->m_poolToken; this->m_poolToken = 0;
         ATH_MSG_ERROR("Failed to read persistent DataType");
         return(StatusCode::FAILURE);
      }
      delete this->m_poolToken; this->m_poolToken = 0;
   }
   T* obj = 0;
   bool success = SG::fromStorable(getDataObject(), obj);
   if (!success || obj == 0) {
      ATH_MSG_ERROR("failed to cast to T for class (type/key) " << className << "/" << getDataObject()->name());
      return(StatusCode::FAILURE);
   }
   setPlacement(key);
   this->m_poolToken = m_athenaPoolCnvSvc->registerForWrite(m_placement, obj, m_classDesc);
   return(StatusCode::SUCCESS);
}
//__________________________________________________________________________
template <class T>
StatusCode T_AthenaPoolCnv<T>::PoolToDataObject(DataObject*& pObj, const std::string& /*token*/) {
   const std::string className = ClassName<T>::name();
   if (!m_dictionaryOkRead) {
      m_dictionaryOkRead = m_athenaPoolCnvSvc->testDictionary(className);
   }
   if (!m_dictionaryOkRead) {
      ATH_MSG_ERROR("There is no correct dictionary for class \"" << className << "\"");
      return(StatusCode::FAILURE);
   }
   void* voidPtr;
   try {
      m_athenaPoolCnvSvc->setObjPtr(voidPtr, this->m_poolToken);
   } catch (std::exception &e) {
      std::string error = e.what();
      ATH_MSG_ERROR("poolToObject: caught error: " << error);
      return(StatusCode::FAILURE);
   }
   T* obj = reinterpret_cast<T*>(voidPtr);
   this->setDataObject(SG::asStorable(obj));
   pObj = this->getDataObject();
   return(StatusCode::SUCCESS);
}
//__________________________________________________________________________
template <class T>
void T_AthenaPoolCnv<T>::setPlacement(const std::string& key) {
   const std::string typenm = ClassName<T>::name();
   setPlacementWithType(typenm, key);
}
